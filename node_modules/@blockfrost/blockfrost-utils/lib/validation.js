"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateAsset = exports.validatePolicy = exports.isNumber = exports.validateBlockHash = exports.validateDerivationXpub = exports.validateInRangeUnsignedInt = exports.validatePositiveInRangeSignedBigInt = exports.validatePositiveInRangeSignedInt = exports.scriptHashFromBech32Address = exports.getAddressTypeAndPaymentCred = exports.detectAndValidateAddressType = exports.paymentCredToBech32Address = exports.paymentCredFromBech32Address = exports.validateAndConvertPool = exports.convertStakeAddress = exports.validateStakeAddress = exports.validateHex = void 0;
const cardano_serialization_lib_nodejs_1 = require("@emurgo/cardano-serialization-lib-nodejs");
const bech32_1 = require("bech32");
// prefixes based on CIP5 https://github.com/cardano-foundation/CIPs/blob/master/CIP-0005/CIP-0005.md
const Prefixes = Object.freeze({
    ADDR: 'addr',
    ADDR_TEST: 'addr_test',
    STAKE: 'stake',
    STAKE_TEST: 'stake_test',
    PAYMENT_KEY_HASH: 'addr_vkh',
    POOL: 'pool',
});
const MAX_UNSIGNED_INT = 2147483648;
const MAX_SIGNED_INT = 2147483647;
const MAX_SIGNED_BIGINT = BigInt('9223372036854775807');
const hexre = new RegExp('^[A-Fa-f0-9]+$');
const validateHex = (input) => {
    try {
        return hexre.test(input);
    }
    catch {
        return false;
    }
};
exports.validateHex = validateHex;
const validateStakeAddress = (input, network) => {
    // validate stake address  (also check network mismatch i.e. mainnet/testnet)
    try {
        const bech32Info = bech32_1.bech32.decode(input, 1000);
        if ((bech32Info.prefix === Prefixes.STAKE && network === 'mainnet') ||
            (bech32Info.prefix === Prefixes.STAKE_TEST && network !== 'mainnet'))
            return true;
        else {
            return false;
        }
    }
    catch {
        return false;
    }
};
exports.validateStakeAddress = validateStakeAddress;
const convertStakeAddress = (input, network) => {
    try {
        if (!(0, exports.validateHex)(input))
            return undefined;
        const words = bech32_1.bech32.toWords(Buffer.from(input, 'hex'));
        // if it's in hex, we'll convert it to Bech32
        return network === 'mainnet'
            ? bech32_1.bech32.encode(Prefixes.STAKE, words)
            : bech32_1.bech32.encode(Prefixes.STAKE_TEST, words);
    }
    catch {
        return undefined;
    }
};
exports.convertStakeAddress = convertStakeAddress;
const validateAndConvertPool = (input) => {
    // if it's hex, it will get converted and checked, otherwise it's bech32 and stays that way
    try {
        if ((0, exports.validateHex)(input)) {
            const words = bech32_1.bech32.toWords(Buffer.from(input, 'hex'));
            // if it's in hex, we'll convert it to Bech32
            const poolId = bech32_1.bech32.encode('pool', words);
            return poolId;
        }
        else {
            const bech32Info = bech32_1.bech32.decode(input, 1000);
            return bech32Info.prefix === Prefixes.POOL ? input : undefined;
        }
    }
    catch {
        return undefined;
    }
};
exports.validateAndConvertPool = validateAndConvertPool;
const paymentCredFromBech32Address = (input) => {
    // compute paymentCred
    try {
        const bech32Info = bech32_1.bech32.decode(input, 1000);
        if (bech32Info.prefix === Prefixes.PAYMENT_KEY_HASH) {
            // valid payment_cred
            const payload = bech32_1.bech32.fromWords(bech32Info.words);
            const paymentCred = `\\x${Buffer.from(payload).toString('hex')}`;
            return paymentCred;
        }
        else {
            return undefined;
        }
    }
    catch {
        return undefined;
    }
};
exports.paymentCredFromBech32Address = paymentCredFromBech32Address;
const paymentCredToBech32Address = (input) => {
    // compute paymentCred
    try {
        if (!(0, exports.validateHex)(input))
            return undefined;
        const words = bech32_1.bech32.toWords(Buffer.from(input, 'hex'));
        // if it's in hex, we'll convert it to Bech32
        return bech32_1.bech32.encode(Prefixes.PAYMENT_KEY_HASH, words);
    }
    catch {
        return undefined;
    }
};
exports.paymentCredToBech32Address = paymentCredToBech32Address;
const detectAndValidateAddressType = (input, network) => {
    // differentiate between various address era formats (byron, shelley)
    try {
        if (cardano_serialization_lib_nodejs_1.ByronAddress.is_valid(input)) {
            // valid byron
            return 'byron';
        }
        else {
            // check if it's not shelley (also check network mismatch i.e. mainnet/testnet)
            const bech32Info = bech32_1.bech32.decode(input, 1000);
            if ((bech32Info.prefix === Prefixes.ADDR && network === 'mainnet') ||
                (bech32Info.prefix === Prefixes.ADDR_TEST && network !== 'mainnet')) {
                // valid shelley - addr1 for mainnet or addr_test1 for testnet
                return 'shelley';
            }
            else if (bech32Info.prefix === Prefixes.PAYMENT_KEY_HASH) {
                // valid shelley - payment_cred
                return 'shelley';
            }
            else {
                return undefined;
            }
        }
    }
    catch {
        return undefined;
    }
};
exports.detectAndValidateAddressType = detectAndValidateAddressType;
const getAddressTypeAndPaymentCred = (address, network) => {
    // check for address validity (undefined) and type (byron, shelley)
    const addressType = (0, exports.detectAndValidateAddressType)(address, network);
    // if shelley, check for paymentCred and compute paymentCred hex
    // if an error occurs or paymentCred can't be computed, undefined is returned
    // which is then handled in the DB as NULL
    const paymentCred = addressType === 'shelley'
        ? (0, exports.paymentCredFromBech32Address)(address)
        : undefined;
    return { addressType, paymentCred };
};
exports.getAddressTypeAndPaymentCred = getAddressTypeAndPaymentCred;
// Decode bech32 script address, drop its first byte (header)
// and return the rest of the bytes, hex encoded.
const scriptHashFromBech32Address = (input) => {
    try {
        const bech32Info = bech32_1.bech32.decode(input, 1000);
        const hash = Buffer.from(bech32_1.bech32.fromWords(bech32Info.words))
            .slice(1)
            .toString('hex');
        return hash;
    }
    catch {
        return undefined;
    }
};
exports.scriptHashFromBech32Address = scriptHashFromBech32Address;
const validatePositiveInRangeSignedInt = (possiblePositiveInt) => {
    try {
        if (typeof possiblePositiveInt === 'undefined' ||
            possiblePositiveInt === '' ||
            Number.isNaN(Number(possiblePositiveInt)) ||
            Number(possiblePositiveInt) < 0 ||
            Number(possiblePositiveInt) > MAX_SIGNED_INT)
            return false;
        else
            return true;
    }
    catch {
        return false;
    }
};
exports.validatePositiveInRangeSignedInt = validatePositiveInRangeSignedInt;
const validatePositiveInRangeSignedBigInt = (possiblePositiveBigInt) => {
    try {
        if (typeof possiblePositiveBigInt === 'undefined' ||
            possiblePositiveBigInt === '' ||
            BigInt(possiblePositiveBigInt) < 0 ||
            BigInt(possiblePositiveBigInt) > MAX_SIGNED_BIGINT)
            return false;
        else
            return true;
    }
    catch {
        return false;
    }
};
exports.validatePositiveInRangeSignedBigInt = validatePositiveInRangeSignedBigInt;
const validateInRangeUnsignedInt = (input) => {
    try {
        if (typeof input === 'undefined' ||
            input === '' ||
            Number.isNaN(Number(input)) ||
            Number(input) < 0 ||
            Number(input) > MAX_UNSIGNED_INT)
            return false;
        else
            return true;
    }
    catch {
        return false;
    }
};
exports.validateInRangeUnsignedInt = validateInRangeUnsignedInt;
const validateDerivationXpub = (input) => {
    return (0, exports.validateHex)(input) && input.length === 128;
};
exports.validateDerivationXpub = validateDerivationXpub;
const validateBlockHash = (input) => {
    return (0, exports.validateHex)(input) && input.length === 64;
};
exports.validateBlockHash = validateBlockHash;
const isNumber = (value) => {
    if (value === '')
        return false;
    return !Number.isNaN(Number(value));
};
exports.isNumber = isNumber;
const validatePolicy = (input) => {
    // policy is always 56 chars long
    return (0, exports.validateHex)(input) && input.length === 56;
};
exports.validatePolicy = validatePolicy;
const validateAsset = (input) => {
    // policy is always 56 chars long
    // asset name is not mandatory, hence between 0 and 64 chars long (56+64=120)
    return (0, exports.validateHex)(input) && input.length >= 56 && input.length <= 120;
};
exports.validateAsset = validateAsset;
