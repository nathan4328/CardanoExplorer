'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var blockfrostJs = require('@blockfrost/blockfrost-js');
var Big = require('big.js');
var invariant = require('@minswap/tiny-invariant');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Big__default = /*#__PURE__*/_interopDefaultLegacy(Big);
var invariant__default = /*#__PURE__*/_interopDefaultLegacy(invariant);

var NetworkId = /* @__PURE__ */ ((NetworkId2) => {
  NetworkId2[NetworkId2["TESTNET"] = 0] = "TESTNET";
  NetworkId2[NetworkId2["MAINNET"] = 1] = "MAINNET";
  return NetworkId2;
})(NetworkId || {});

const ORDER_ADDRESS = {
  [NetworkId.TESTNET]: "addr_test1wzn9efv2f6w82hagxqtn62ju4m293tqvw0uhmdl64ch8uwc5lpd8w",
  [NetworkId.MAINNET]: "addr1wxn9efv2f6w82hagxqtn62ju4m293tqvw0uhmdl64ch8uwc0h43gt"
};
const POOL_ADDRESS = {
  [NetworkId.TESTNET]: "addr_test1zrsnz7c4974vzdpxu65ruphl3zjdvtxw8strf2c2tmqnxzvrajt8r8wqtygrfduwgukk73m5gcnplmztc5tl5ngy0upqs8q93k",
  [NetworkId.MAINNET]: "addr1z8snz7c4974vzdpxu65ruphl3zjdvtxw8strf2c2tmqnxz2j2c79gy9l76sdg0xwhd7r0c0kna0tycz4y5s6mlenh8pq0xmsha"
};
const FACTORY_POLICY_ID = "13aa2accf2e1561723aa26871e071fdf32c867cff7e7d50ad470d62f";
const FACTORY_ASSET_NAME = "4d494e53574150";
const LP_POLICY_ID = "e4214b7cce62ac6fbba385d164df48e157eae5863521b4b67ca71d86";
const POOL_NFT_POLICY_ID = "0be55d262b29f564998ff81efe21bdc0022621c12f15af08d0f2ddb1";

function normalizeAssets(a, b) {
  if (a === "lovelace") {
    return [a, b];
  }
  if (b === "lovelace") {
    return [b, a];
  }
  if (a < b) {
    return [a, b];
  } else {
    return [b, a];
  }
}
class PoolState {
  constructor(txIn, value, datumHash) {
    this.txIn = txIn;
    this.value = value;
    this.datumHash = datumHash;
    const nft = value.find(({ unit }) => unit.startsWith(POOL_NFT_POLICY_ID));
    invariant__default["default"](nft, "pool doesn't have NFT");
    const poolId = nft.unit.slice(56);
    const relevantAssets = value.filter(({ unit }) => !unit.startsWith(FACTORY_POLICY_ID) && !unit.endsWith(poolId));
    switch (relevantAssets.length) {
      case 2: {
        this.assetA = "lovelace";
        const nonADAAssets = relevantAssets.filter(({ unit }) => unit !== "lovelace");
        invariant__default["default"](nonADAAssets.length === 1, "pool must have 1 non-ADA asset");
        this.assetB = nonADAAssets[0].unit;
        break;
      }
      case 3: {
        const nonADAAssets = relevantAssets.filter(({ unit }) => unit !== "lovelace");
        invariant__default["default"](nonADAAssets.length === 2, "pool must have 1 non-ADA asset");
        [this.assetA, this.assetB] = normalizeAssets(nonADAAssets[0].unit, nonADAAssets[1].unit);
        break;
      }
      default:
        throw new Error("pool must have 2 or 3 assets except factory, NFT and LP tokens");
    }
  }
  get nft() {
    const nft = this.value.find(({ unit }) => unit.startsWith(POOL_NFT_POLICY_ID));
    invariant__default["default"](nft, "pool doesn't have NFT");
    return nft.unit;
  }
  get id() {
    return this.nft.slice(POOL_NFT_POLICY_ID.length);
  }
  get assetLP() {
    return `${LP_POLICY_ID}${this.id}`;
  }
  get reserveA() {
    return BigInt(this.value.find(({ unit }) => unit === this.assetA)?.quantity ?? "0");
  }
  get reserveB() {
    return BigInt(this.value.find(({ unit }) => unit === this.assetB)?.quantity ?? "0");
  }
  getAmountOut(assetIn, amountIn) {
    invariant__default["default"](assetIn === this.assetA || assetIn === this.assetB, `asset ${assetIn} doesn't exist in pool ${this.assetA}-${this.assetB}`);
    const [reserveIn, reserveOut] = assetIn === this.assetA ? [this.reserveA, this.reserveB] : [this.reserveB, this.reserveA];
    const numerator = amountIn * 997n * reserveOut;
    const denominator = amountIn * 997n + reserveIn * 1000n;
    return numerator / denominator;
  }
  getAmountIn(assetOut, amountOut) {
    invariant__default["default"](assetOut === this.assetA || assetOut === this.assetB, `asset ${assetOut} doesn't exist in pool ${this.assetA}-${this.assetB}`);
    const [reserveIn, reserveOut] = assetOut === this.assetB ? [this.reserveA, this.reserveB] : [this.reserveB, this.reserveA];
    const numerator = reserveIn * amountOut * 1000n;
    const denominator = (reserveOut - amountOut) * 997n;
    return numerator / denominator + 1n;
  }
}
function checkValidPoolOutput(networkId, address, value, datumHash) {
  invariant__default["default"](address === POOL_ADDRESS[networkId], `expect pool address of ${POOL_ADDRESS[networkId]}, got ${address}`);
  if (value.find(({ unit }) => unit === `${FACTORY_POLICY_ID}${FACTORY_ASSET_NAME}`)?.quantity !== "1") {
    throw new Error(`expect pool to have 1 factory token`);
  }
  invariant__default["default"](datumHash, `expect pool to have datum hash, got ${datumHash}`);
}
function isValidPoolOutput(networkId, address, value, datumHash) {
  try {
    checkValidPoolOutput(networkId, address, value, datumHash);
    return true;
  } catch (err) {
    return false;
  }
}

class BlockfrostAdapter {
  constructor({
    projectId,
    networkId = NetworkId.MAINNET
  }) {
    this.networkId = networkId;
    this.api = new blockfrostJs.BlockFrostAPI({
      projectId,
      isTestnet: networkId === NetworkId.TESTNET
    });
  }
  async getPools({
    page,
    count = 100,
    order = "asc"
  }) {
    const utxos = await this.api.addressesUtxos(POOL_ADDRESS[this.networkId], {
      count,
      order,
      page
    });
    return utxos.filter((utxo) => isValidPoolOutput(this.networkId, POOL_ADDRESS[this.networkId], utxo.amount, utxo.data_hash)).map((utxo) => new PoolState({ txHash: utxo.tx_hash, index: utxo.output_index }, utxo.amount, utxo.data_hash));
  }
  async getPoolById({
    id
  }) {
    const nft = `${POOL_NFT_POLICY_ID}${id}`;
    const nftTxs = await this.api.assetsTransactions(nft, {
      count: 1,
      page: 1,
      order: "desc"
    });
    if (nftTxs.length === 0) {
      return null;
    }
    return this.getPoolInTx({ txHash: nftTxs[0].tx_hash });
  }
  async getPoolHistory({
    id,
    page = 1,
    count = 100,
    order = "desc"
  }) {
    const nft = `${POOL_NFT_POLICY_ID}${id}`;
    const nftTxs = await this.api.assetsTransactions(nft, {
      count,
      page,
      order
    });
    return nftTxs.map((tx) => ({
      txHash: tx.tx_hash,
      txIndex: tx.tx_index,
      blockHeight: tx.block_height,
      time: new Date(Number(tx.block_time) * 1e3)
    }));
  }
  async getPoolInTx({
    txHash
  }) {
    const poolTx = await this.api.txsUtxos(txHash);
    const poolUtxo = poolTx.outputs.find((o) => o.address === POOL_ADDRESS[this.networkId]);
    if (!poolUtxo) {
      return null;
    }
    checkValidPoolOutput(this.networkId, poolUtxo.address, poolUtxo.amount, poolUtxo.data_hash);
    return new PoolState({ txHash, index: poolUtxo.output_index }, poolUtxo.amount, poolUtxo.data_hash);
  }
  async getAssetDecimals(asset) {
    if (asset === "lovelace") {
      return 6;
    }
    try {
      const assetAInfo = await this.api.assetsById(asset);
      return assetAInfo.metadata?.decimals ?? 0;
    } catch (err) {
      if (err instanceof blockfrostJs.BlockfrostServerError && err.status_code === 404) {
        return 0;
      }
      throw err;
    }
  }
  async getPoolPrice({
    pool,
    decimalsA,
    decimalsB
  }) {
    if (decimalsA === void 0) {
      decimalsA = await this.getAssetDecimals(pool.assetA);
    }
    if (decimalsB === void 0) {
      decimalsB = await this.getAssetDecimals(pool.assetB);
    }
    const adjustedReserveA = Big__default["default"](pool.reserveA.toString()).div(Big__default["default"](10).pow(decimalsA));
    const adjustedReserveB = Big__default["default"](pool.reserveB.toString()).div(Big__default["default"](10).pow(decimalsB));
    const priceAB = adjustedReserveA.div(adjustedReserveB);
    const priceBA = adjustedReserveB.div(adjustedReserveA);
    return [priceAB, priceBA];
  }
}

exports.BlockfrostAdapter = BlockfrostAdapter;
exports.FACTORY_ASSET_NAME = FACTORY_ASSET_NAME;
exports.FACTORY_POLICY_ID = FACTORY_POLICY_ID;
exports.LP_POLICY_ID = LP_POLICY_ID;
exports.NetworkId = NetworkId;
exports.ORDER_ADDRESS = ORDER_ADDRESS;
exports.POOL_ADDRESS = POOL_ADDRESS;
exports.POOL_NFT_POLICY_ID = POOL_NFT_POLICY_ID;
exports.PoolState = PoolState;
//# sourceMappingURL=index.js.map
