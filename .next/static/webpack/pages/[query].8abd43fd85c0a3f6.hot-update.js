"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/[query]",{

/***/ "./pages/token.js":
/*!************************!*\
  !*** ./pages/token.js ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Token; }\n/* harmony export */ });\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n// if metadata has been fetched\n// find the ipfs link under 'image' metadata tag and store it\nconst getIpfsFromMetadata = (metadata)=>{\n    const keys = Object.keys(metadata);\n    const values = Object.values(metadata);\n    let ipfs = \"\";\n    for(let i = 0; i < keys.length; i++){\n        if (keys[i] == \"image\") {\n            ipfs = values[i];\n        } else if (keys[i] == \"logo\") {\n            return \"data:image/png;base64,\" + values[i];\n        }\n    }\n    // convert all ipfs formats to the a searchable format that can be fetched in a <img> tag\n    try {\n        // links are sometimes stored in arrays\n        // this finds ipfs links in the array\n        if (Array.isArray(ipfs)) {\n            let newipfs = \"\";\n            for (const element of ipfs){\n                newipfs = newipfs + element;\n            }\n            if (newipfs.startsWith(\"ipfs://\")) {\n                newipfs = newipfs.slice(7);\n                if (newipfs.startsWith(\"ipfs/\")) {\n                    newipfs = newipfs.slice(5);\n                }\n                newipfs = \"http://dweb.link/ipfs/\" + newipfs;\n            } else if (newipfs.startsWith(\"ipfs/\")) {\n                newipfs = newipfs.slice(5);\n                newipfs = \"http://dweb.link/ipfs/\" + newipfs;\n            } else if (newipfs.startsWith(\"Qm\")) {\n                newipfs = \"http://dweb.link/ipfs/\" + newipfs;\n            }\n            return newipfs;\n        }\n        // normal ipfs in image tags\n        if (ipfs.startsWith(\"ipfs://\")) {\n            ipfs = ipfs.slice(7);\n            if (ipfs.startsWith(\"ipfs/\")) {\n                ipfs = ipfs.slice(5);\n            }\n            ipfs = \"http://dweb.link/ipfs/\" + ipfs;\n        } else if (ipfs.startsWith(\"ipfs/\")) {\n            ipfs = ipfs.slice(5);\n            ipfs = \"http://dweb.link/ipfs/\" + ipfs;\n        } else if (ipfs.startsWith(\"Qm\")) {\n            ipfs = \"http://dweb.link/ipfs/\" + ipfs;\n        }\n    } catch (e) {\n        return \"/black.jpeg\";\n    }\n    if (ipfs.startsWith(\"ba\")) {\n        ipfs = \"http://dweb.link/ipfs/\" + ipfs;\n    }\n    return ipfs;\n};\nclass Token {\n    async fetchTokenMetadata() {\n        try {\n            let req = await fetch(\"https://api.koios.rest/api/v0/asset_info?_asset_policy=\" + this.policy_id + \"&_asset_name=\" + this.asset_name);\n            let res = await req.json();\n            let decod = Buffer.from(this.asset_name, \"hex\").toString();\n            try {\n                if (res[0].minting_tx_metadata && res[0].minting_tx_metadata[721]) {\n                    if (res[0].minting_tx_metadata[721][this.policy_id][decod]) {\n                        this.onchain_metadata = res[0].minting_tx_metadata[721][this.policy_id][decod];\n                        this.ipfs = getIpfsFromMetadata(res[0].minting_tx_metadata[721][this.policy_id][decod]);\n                        if (this.ipfs == \"/black.jpeg\") {\n                            this.ipfs = getIpfsFromMetadata(res[0].token_registry_metadata);\n                        }\n                    } else {\n                        this.onchain_metadata = res[0].minting_tx_metadata;\n                    }\n                }\n                if (res[0].token_registry_metadata) {\n                    this.metadata = res[0].token_registry_metadata;\n                    let ipfs = getIpfsFromMetadata(res[0].token_registry_metadata);\n                    if (ipfs != \"\") {\n                        this.ipfs = ipfs;\n                    } else {}\n                } else if (!res[0].minting_tx_metadata) {\n                    console.log(\"no metadata found\");\n                }\n            } catch (error) {\n                console.error(error, res);\n            }\n        } catch (error) {\n            console.error(\"Error in fetchTokenMetadata:\", error);\n        }\n    }\n    async fetchTokenPrice() {\n        if (this.quantity == 1) {\n            try {\n                let request = await fetch(\"https://api.opencnft.io/2/collection/\" + this.policy_id + \"/floor_price\", {\n                    headers: {\n                        \"X-Api-Key\": \"ocnft_64230513320ac06596270a21\"\n                    }\n                });\n                if (request.status == 429) {\n                    //wait 5 seconds and try again\n                    await new Promise((r)=>setTimeout(r, 200));\n                    request = await fetch(\"https://api.opencnft.io/2/collection/\" + this.policy_id + \"/floor_price\", {\n                        headers: {\n                            \"X-Api-Key\": \"ocnft_64230513320ac06596270a21\"\n                        }\n                    });\n                } else if (request.status == 200) {\n                    let opencnftData = await request.json();\n                    if (opencnftData.floor_price) {\n                        this.floor_price = opencnftData.floor_price / 1000000;\n                        console.log(\"floor price: \", this.floor_price);\n                    }\n                } else {\n                    this.floor_price = 0;\n                }\n            } catch (error) {\n                this.floor_price = 0;\n                throw new Error(\"Error in OpenCNFT\");\n            }\n        } else {\n            try {\n                var _this_metadata;\n                let request = await fetch(\"/coin-gecko-id-cardano.json\");\n                let geckoData = await request.json();\n                let ticker = (_this_metadata = this.metadata) === null || _this_metadata === void 0 ? void 0 : _this_metadata.ticker;\n                if (!ticker) {\n                    return;\n                }\n                let foundGeckoCoin = geckoData.find((item)=>item.symbol === ticker.toLowerCase());\n                if (!foundGeckoCoin) {\n                    return;\n                }\n                let req = await fetch(\"https://api.coingecko.com/api/v3/coins/\".concat(foundGeckoCoin.id));\n                let res = await req.json();\n                let priceData = res.market_data;\n                this.prices = {\n                    current: priceData.current_price.usd,\n                    change24h: priceData.price_change_percentage_24h,\n                    change7d: priceData.price_change_percentage_7d,\n                    change30d: priceData.price_change_percentage_30d,\n                    change1y: priceData.price_change_percentage_1y\n                };\n            } catch (error) {\n                throw new Error(error);\n            }\n        }\n    }\n    constructor(asset_name, policy_id, quantity){\n        this.asset_name = asset_name;\n        this.policy_id = policy_id;\n        this.quantity = quantity;\n        this.onchain_metadata = null;\n        this.metadata = null;\n        this.ipfs = \"/black.jpeg\";\n        this.prices = null;\n        this.decoded_name = Buffer.from(asset_name, \"hex\").toString();\n        this.floor_price = null;\n    }\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFBSSxDQUFDSixnQkFBZ0I7b0JBQ25CO2dCQUNGLENBQUM7Z0JBRUQsSUFBSTdCLE1BQU0sTUFBTUMsTUFBTSwwQ0FBNEQsT0FBbEI0QixlQUFlSyxFQUFFO2dCQUNqRixJQUFJOUIsTUFBTSxNQUFNSixJQUFJSyxJQUFJO2dCQUN4QixJQUFJOEIsWUFBWS9CLElBQUlnQyxXQUFXO2dCQUMvQixJQUFJLENBQUNDLE1BQU0sR0FBRztvQkFDWkMsU0FBU0gsVUFBVUksYUFBYSxDQUFDQyxHQUFHO29CQUNwQ0MsV0FBV04sVUFBVU8sMkJBQTJCO29CQUNoREMsVUFBVVIsVUFBVVMsMEJBQTBCO29CQUM5Q0MsV0FBV1YsVUFBVVcsMkJBQTJCO29CQUNoREMsVUFBVVosVUFBVWEsMEJBQTBCO2dCQUNoRDtZQUNGLEVBQUUsT0FBT2pDLE9BQU87Z0JBQ2QsTUFBTSxJQUFJVyxNQUFNWCxPQUFPO1lBQ3pCO1FBQ0YsQ0FBQztJQUdIO0lBL0dBa0MsWUFBWTlDLFVBQVUsRUFBRUQsU0FBUyxFQUFFZSxRQUFRLENBQUU7UUFDM0MsSUFBSSxDQUFDZCxVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ0QsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNlLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDTixnQkFBZ0IsR0FBRyxJQUFJO1FBQzVCLElBQUksQ0FBQzFCLFFBQVEsR0FBRyxJQUFJO1FBQ3BCLElBQUksQ0FBQ0ksSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDZ0QsTUFBTSxHQUFHLElBQUk7UUFDbEIsSUFBSSxDQUFDYSxZQUFZLEdBQUkzQyxNQUFNQSxDQUFDQyxJQUFJLENBQUNMLFlBQVksT0FBT00sUUFBUTtRQUM1RCxJQUFJLENBQUNnQixXQUFXLEdBQUcsSUFBSTtJQUN6QjtBQXNHRjtBQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3BhZ2VzL3Rva2VuLmpzP2YzM2EiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaWYgbWV0YWRhdGEgaGFzIGJlZW4gZmV0Y2hlZFxuLy8gZmluZCB0aGUgaXBmcyBsaW5rIHVuZGVyICdpbWFnZScgbWV0YWRhdGEgdGFnIGFuZCBzdG9yZSBpdFxuY29uc3QgZ2V0SXBmc0Zyb21NZXRhZGF0YSA9IChtZXRhZGF0YSkgPT57XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobWV0YWRhdGEpO1xuICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhtZXRhZGF0YSk7XG4gICAgICBsZXQgaXBmcyA9IFwiXCI7XG4gICAgICBmb3IobGV0IGk9MDtpPGtleXMubGVuZ3RoO2krKyl7XG5cblxuICAgICAgICBpZihrZXlzW2ldID09IFwiaW1hZ2VcIil7XG4gICAgICAgICAgaXBmcyA9IHZhbHVlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gZnVuZ2libGUgdG9rZW5zIHdpbGwgaGF2ZSBhICdsb2dvJyBpbnN0ZWFkIG9mICdpbWFnZScgdGFnXG4gICAgICAgIGVsc2UgaWYoa2V5c1tpXSA9PSBcImxvZ29cIil7XG4gICAgICAgICAgcmV0dXJuIFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LFwiK3ZhbHVlc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gY29udmVydCBhbGwgaXBmcyBmb3JtYXRzIHRvIHRoZSBhIHNlYXJjaGFibGUgZm9ybWF0IHRoYXQgY2FuIGJlIGZldGNoZWQgaW4gYSA8aW1nPiB0YWdcbiAgICAgIHRyeXtcblxuICAgICAgICAvLyBsaW5rcyBhcmUgc29tZXRpbWVzIHN0b3JlZCBpbiBhcnJheXNcbiAgICAgICAgLy8gdGhpcyBmaW5kcyBpcGZzIGxpbmtzIGluIHRoZSBhcnJheVxuICAgICAgICBpZihBcnJheS5pc0FycmF5KGlwZnMpKXtcbiAgICAgICAgICBsZXQgbmV3aXBmcyA9IFwiXCI7XG4gICAgICAgICAgZm9yKGNvbnN0IGVsZW1lbnQgb2YgaXBmcyl7XG4gICAgICAgICAgICBuZXdpcGZzID0gbmV3aXBmcyArIGVsZW1lbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYobmV3aXBmcy5zdGFydHNXaXRoKCdpcGZzOi8vJykpe1xuICAgICAgICAgICAgbmV3aXBmcyA9IG5ld2lwZnMuc2xpY2UoNyk7XG4gICAgICAgICAgICBpZihuZXdpcGZzLnN0YXJ0c1dpdGgoJ2lwZnMvJykpe1xuICAgICAgICAgICAgICBuZXdpcGZzID0gbmV3aXBmcy5zbGljZSg1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld2lwZnMgPSBcImh0dHA6Ly9kd2ViLmxpbmsvaXBmcy9cIituZXdpcGZzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsc2UgaWYobmV3aXBmcy5zdGFydHNXaXRoKCdpcGZzLycpKXtcbiAgICAgICAgICAgIG5ld2lwZnMgPSBuZXdpcGZzLnNsaWNlKDUpO1xuICAgICAgICAgICAgbmV3aXBmcyA9IFwiaHR0cDovL2R3ZWIubGluay9pcGZzL1wiK25ld2lwZnM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxzZSBpZihuZXdpcGZzLnN0YXJ0c1dpdGgoJ1FtJykpe1xuICAgICAgICAgICAgbmV3aXBmcyA9IFwiaHR0cDovL2R3ZWIubGluay9pcGZzL1wiK25ld2lwZnM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXdpcGZzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm9ybWFsIGlwZnMgaW4gaW1hZ2UgdGFnc1xuICAgICAgICBpZihpcGZzLnN0YXJ0c1dpdGgoJ2lwZnM6Ly8nKSl7XG4gICAgICAgICAgaXBmcyA9IGlwZnMuc2xpY2UoNyk7XG4gICAgICAgICAgaWYoaXBmcy5zdGFydHNXaXRoKCdpcGZzLycpKXtcbiAgICAgICAgICAgIGlwZnMgPSBpcGZzLnNsaWNlKDUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpcGZzID0gXCJodHRwOi8vZHdlYi5saW5rL2lwZnMvXCIraXBmcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGlwZnMuc3RhcnRzV2l0aCgnaXBmcy8nKSl7XG4gICAgICAgICAgaXBmcyA9IGlwZnMuc2xpY2UoNSk7XG4gICAgICAgICAgaXBmcyA9IFwiaHR0cDovL2R3ZWIubGluay9pcGZzL1wiK2lwZnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihpcGZzLnN0YXJ0c1dpdGgoJ1FtJykpe1xuICAgICAgICAgIGlwZnMgPSBcImh0dHA6Ly9kd2ViLmxpbmsvaXBmcy9cIitpcGZzO1xuICAgICAgICB9XG5cbiAgICAgIH1jYXRjaHtcbiAgICAgICAgcmV0dXJuICcvYmxhY2suanBlZyc7XG4gICAgICB9XG5cbiAgICAgIGlmKGlwZnMuc3RhcnRzV2l0aCgnYmEnKSl7XG4gICAgICAgIGlwZnMgPSBcImh0dHA6Ly9kd2ViLmxpbmsvaXBmcy9cIitpcGZzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlwZnM7XG4gICAgfVxuXG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG9rZW4ge1xuICBjb25zdHJ1Y3Rvcihhc3NldF9uYW1lLCBwb2xpY3lfaWQsIHF1YW50aXR5KSB7XG4gICAgdGhpcy5hc3NldF9uYW1lID0gYXNzZXRfbmFtZTtcbiAgICB0aGlzLnBvbGljeV9pZCA9IHBvbGljeV9pZDtcbiAgICB0aGlzLnF1YW50aXR5ID0gcXVhbnRpdHk7XG4gICAgdGhpcy5vbmNoYWluX21ldGFkYXRhID0gbnVsbDtcbiAgICB0aGlzLm1ldGFkYXRhID0gbnVsbDtcbiAgICB0aGlzLmlwZnMgPSAnL2JsYWNrLmpwZWcnO1xuICAgIHRoaXMucHJpY2VzID0gbnVsbDtcbiAgICB0aGlzLmRlY29kZWRfbmFtZSA9ICBCdWZmZXIuZnJvbShhc3NldF9uYW1lLCAnaGV4JykudG9TdHJpbmcoKTtcbiAgICB0aGlzLmZsb29yX3ByaWNlID0gbnVsbDtcbiAgfVxuXG4gIGFzeW5jIGZldGNoVG9rZW5NZXRhZGF0YSgpIHtcbiAgICB0cnkge1xuICAgICAgbGV0IHJlcSA9IGF3YWl0IGZldGNoKCdodHRwczovL2FwaS5rb2lvcy5yZXN0L2FwaS92MC9hc3NldF9pbmZvP19hc3NldF9wb2xpY3k9JyArIHRoaXMucG9saWN5X2lkICsgJyZfYXNzZXRfbmFtZT0nICsgdGhpcy5hc3NldF9uYW1lKTtcbiAgICAgIGxldCByZXMgPSBhd2FpdCByZXEuanNvbigpO1xuICAgICAgbGV0IGRlY29kID0gQnVmZmVyLmZyb20odGhpcy5hc3NldF9uYW1lLCAnaGV4JykudG9TdHJpbmcoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChyZXNbMF0ubWludGluZ190eF9tZXRhZGF0YSAmJiByZXNbMF0ubWludGluZ190eF9tZXRhZGF0YVs3MjFdKSB7XG4gICAgICAgICAgaWYgKHJlc1swXS5taW50aW5nX3R4X21ldGFkYXRhWzcyMV1bdGhpcy5wb2xpY3lfaWRdW2RlY29kXSkge1xuICAgICAgICAgICAgdGhpcy5vbmNoYWluX21ldGFkYXRhID0gcmVzWzBdLm1pbnRpbmdfdHhfbWV0YWRhdGFbNzIxXVt0aGlzLnBvbGljeV9pZF1bZGVjb2RdO1xuICAgICAgICAgICAgdGhpcy5pcGZzID0gZ2V0SXBmc0Zyb21NZXRhZGF0YShyZXNbMF0ubWludGluZ190eF9tZXRhZGF0YVs3MjFdW3RoaXMucG9saWN5X2lkXVtkZWNvZF0pO1xuICBcbiAgICAgICAgICAgIGlmICh0aGlzLmlwZnMgPT0gJy9ibGFjay5qcGVnJykge1xuICAgICAgICAgICAgICB0aGlzLmlwZnMgPSBnZXRJcGZzRnJvbU1ldGFkYXRhKHJlc1swXS50b2tlbl9yZWdpc3RyeV9tZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25jaGFpbl9tZXRhZGF0YSA9IHJlc1swXS5taW50aW5nX3R4X21ldGFkYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzWzBdLnRva2VuX3JlZ2lzdHJ5X21ldGFkYXRhKSB7XG4gICAgICAgICAgdGhpcy5tZXRhZGF0YSA9IHJlc1swXS50b2tlbl9yZWdpc3RyeV9tZXRhZGF0YTtcbiAgICAgICAgICBsZXQgaXBmcyA9IGdldElwZnNGcm9tTWV0YWRhdGEocmVzWzBdLnRva2VuX3JlZ2lzdHJ5X21ldGFkYXRhKTtcbiAgICAgICAgICBpZihpcGZzICE9ICcnKXtcbiAgICAgICAgICAgIHRoaXMuaXBmcyA9IGlwZnM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFyZXNbMF0ubWludGluZ190eF9tZXRhZGF0YSApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIm5vIG1ldGFkYXRhIGZvdW5kXCIpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yLCByZXMpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gZmV0Y2hUb2tlbk1ldGFkYXRhOlwiLCBlcnJvcik7XG4gICAgfVxuICB9XG4gIFxuXG5cbiAgYXN5bmMgZmV0Y2hUb2tlblByaWNlKCkge1xuICAgIGlmICh0aGlzLnF1YW50aXR5ID09IDEpIHtcbiAgICAgIHRyeXtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9hcGkub3BlbmNuZnQuaW8vMi9jb2xsZWN0aW9uLycrdGhpcy5wb2xpY3lfaWQrJy9mbG9vcl9wcmljZScsXG4gICAgICAgIHtoZWFkZXJzOiB7XCJYLUFwaS1LZXlcIjogXCJvY25mdF82NDIzMDUxMzMyMGFjMDY1OTYyNzBhMjFcIn19KTtcblxuICAgICAgICBpZihyZXF1ZXN0LnN0YXR1cyA9PSA0Mjkpe1xuXG4gICAgICAgICAgLy93YWl0IDUgc2Vjb25kcyBhbmQgdHJ5IGFnYWluXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UociA9PiBzZXRUaW1lb3V0KHIsIDIwMCkpO1xuICAgICAgICAgIHJlcXVlc3QgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9hcGkub3BlbmNuZnQuaW8vMi9jb2xsZWN0aW9uLycrdGhpcy5wb2xpY3lfaWQrJy9mbG9vcl9wcmljZScsXG4gICAgICAgICAge2hlYWRlcnM6IHtcIlgtQXBpLUtleVwiOiBcIm9jbmZ0XzY0MjMwNTEzMzIwYWMwNjU5NjI3MGEyMVwifX0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYocmVxdWVzdC5zdGF0dXMgPT0gMjAwKXtcbiAgICAgICAgICBsZXQgb3BlbmNuZnREYXRhID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG4gICAgICAgICAgaWYob3BlbmNuZnREYXRhLmZsb29yX3ByaWNlKXtcbiAgICAgICAgICAgIHRoaXMuZmxvb3JfcHJpY2UgPSAob3BlbmNuZnREYXRhLmZsb29yX3ByaWNlLzEwMDAwMDApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJmbG9vciBwcmljZTogXCIsIHRoaXMuZmxvb3JfcHJpY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgIHRoaXMuZmxvb3JfcHJpY2UgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYXRjaChlcnJvcil7XG4gICAgICAgIHRoaXMuZmxvb3JfcHJpY2UgPSAwO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGluIE9wZW5DTkZUJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2V7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgcmVxdWVzdCA9IGF3YWl0IGZldGNoKCcvY29pbi1nZWNrby1pZC1jYXJkYW5vLmpzb24nKTtcbiAgICAgICAgbGV0IGdlY2tvRGF0YSA9IGF3YWl0IHJlcXVlc3QuanNvbigpO1xuICAgICAgICBsZXQgdGlja2VyID0gKHRoaXMubWV0YWRhdGE/LnRpY2tlcik7XG4gICAgICBcbiAgICAgICAgaWYgKCF0aWNrZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIFxuICAgICAgICBsZXQgZm91bmRHZWNrb0NvaW4gPSBnZWNrb0RhdGEuZmluZChpdGVtID0+IGl0ZW0uc3ltYm9sID09PSB0aWNrZXIudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGlmICghZm91bmRHZWNrb0NvaW4pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIFxuICAgICAgICBsZXQgcmVxID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vYXBpLmNvaW5nZWNrby5jb20vYXBpL3YzL2NvaW5zLyR7Zm91bmRHZWNrb0NvaW4uaWR9YCk7XG4gICAgICAgIGxldCByZXMgPSBhd2FpdCByZXEuanNvbigpO1xuICAgICAgICBsZXQgcHJpY2VEYXRhID0gcmVzLm1hcmtldF9kYXRhO1xuICAgICAgICB0aGlzLnByaWNlcyA9IHtcbiAgICAgICAgICBjdXJyZW50OiBwcmljZURhdGEuY3VycmVudF9wcmljZS51c2QsXG4gICAgICAgICAgY2hhbmdlMjRoOiBwcmljZURhdGEucHJpY2VfY2hhbmdlX3BlcmNlbnRhZ2VfMjRoLFxuICAgICAgICAgIGNoYW5nZTdkOiBwcmljZURhdGEucHJpY2VfY2hhbmdlX3BlcmNlbnRhZ2VfN2QsXG4gICAgICAgICAgY2hhbmdlMzBkOiBwcmljZURhdGEucHJpY2VfY2hhbmdlX3BlcmNlbnRhZ2VfMzBkLFxuICAgICAgICAgIGNoYW5nZTF5OiBwcmljZURhdGEucHJpY2VfY2hhbmdlX3BlcmNlbnRhZ2VfMXksXG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBcblxuICB9XG59ICAgIFxuIl0sIm5hbWVzIjpbImdldElwZnNGcm9tTWV0YWRhdGEiLCJtZXRhZGF0YSIsImtleXMiLCJPYmplY3QiLCJ2YWx1ZXMiLCJpcGZzIiwiaSIsImxlbmd0aCIsIkFycmF5IiwiaXNBcnJheSIsIm5ld2lwZnMiLCJlbGVtZW50Iiwic3RhcnRzV2l0aCIsInNsaWNlIiwiVG9rZW4iLCJmZXRjaFRva2VuTWV0YWRhdGEiLCJyZXEiLCJmZXRjaCIsInBvbGljeV9pZCIsImFzc2V0X25hbWUiLCJyZXMiLCJqc29uIiwiZGVjb2QiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJtaW50aW5nX3R4X21ldGFkYXRhIiwib25jaGFpbl9tZXRhZGF0YSIsInRva2VuX3JlZ2lzdHJ5X21ldGFkYXRhIiwiY29uc29sZSIsImxvZyIsImVycm9yIiwiZmV0Y2hUb2tlblByaWNlIiwicXVhbnRpdHkiLCJyZXF1ZXN0IiwiaGVhZGVycyIsInN0YXR1cyIsIlByb21pc2UiLCJyIiwic2V0VGltZW91dCIsIm9wZW5jbmZ0RGF0YSIsImZsb29yX3ByaWNlIiwiRXJyb3IiLCJnZWNrb0RhdGEiLCJ0aWNrZXIiLCJmb3VuZEdlY2tvQ29pbiIsImZpbmQiLCJpdGVtIiwic3ltYm9sIiwidG9Mb3dlckNhc2UiLCJpZCIsInByaWNlRGF0YSIsIm1hcmtldF9kYXRhIiwicHJpY2VzIiwiY3VycmVudCIsImN1cnJlbnRfcHJpY2UiLCJ1c2QiLCJjaGFuZ2UyNGgiLCJwcmljZV9jaGFuZ2VfcGVyY2VudGFnZV8yNGgiLCJjaGFuZ2U3ZCIsInByaWNlX2NoYW5nZV9wZXJjZW50YWdlXzdkIiwiY2hhbmdlMzBkIiwicHJpY2VfY2hhbmdlX3BlcmNlbnRhZ2VfMzBkIiwiY2hhbmdlMXkiLCJwcmljZV9jaGFuZ2VfcGVyY2VudGFnZV8xeSIsImNvbnN0cnVjdG9yIiwiZGVjb2RlZF9uYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/token.js\n"));

/***/ })

});