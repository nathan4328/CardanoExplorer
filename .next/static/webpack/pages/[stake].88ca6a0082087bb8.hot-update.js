"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/[stake]",{

/***/ "./src/pages/walletData.js":
/*!*********************************!*\
  !*** ./src/pages/walletData.js ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.a(module, async function (__webpack_handle_async_dependencies__, __webpack_async_result__) { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _token__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./token */ \"./src/pages/token.js\");\n/* harmony import */ var _nfts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nfts */ \"./src/pages/nfts.js\");\n/* harmony import */ var _fts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fts */ \"./src/pages/fts.js\");\n/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tokens */ \"./src/pages/tokens.js\");\n/* harmony import */ var next_config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next.config */ \"./next.config.js\");\n/* harmony import */ var next_config__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_config__WEBPACK_IMPORTED_MODULE_6__);\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_fts__WEBPACK_IMPORTED_MODULE_4__, _tokens__WEBPACK_IMPORTED_MODULE_5__]);\n([_fts__WEBPACK_IMPORTED_MODULE_4__, _tokens__WEBPACK_IMPORTED_MODULE_5__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\nfunction WalletData(props) {\n    _s();\n    const [isVisibleGrid, setIsVisibleGrid] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const [isLoading, setisLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isVisible, setIsVisible] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [loadingInfo, setLoadingInfo] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const [stakeData, setStakeData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        stake: null,\n        tokenNumber: null,\n        projectNumber: null,\n        nfts: null,\n        fts: null\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const getTokens = async ()=>{\n            if (props.stakeAddress == null) {\n            //base\n            } else {\n                //loading icon\n                setisLoading(\"fetching\");\n                setIsVisibleGrid(false);\n                setIsVisible(true);\n                // props passed from [stake].js\n                let stakeAddress = props.stakeAddress;\n                // check if stake is a handle\n                // then get base address then stake address from that handle\n                if (stakeAddress.startsWith(\"$\")) {\n                    let stake = await getAddressFromHandle(stakeAddress.slice(1));\n                    if (stake != null) {\n                        stakeAddress = stake;\n                    } else {\n                        console.log(\"wallet error\");\n                    }\n                }\n                // used to store and retrieve wallet information in local storage\n                let stakeData = \"\";\n                //if stake data exist in storage -- get it\n                if (localStorage.getItem(stakeAddress)) {\n                    stakeData = JSON.parse(localStorage.getItem(stakeAddress));\n                } else {\n                    stakeData = await createStakeDataFromStakeAddress(stakeAddress);\n                    if (stakeData != null) {\n                        localStorage.setItem(stakeAddress, JSON.stringify(stakeData));\n                    }\n                }\n                // loading icon\n                setStakeData(stakeData);\n                setisLoading(\"done\");\n                setIsVisible(false);\n                setIsVisibleGrid(true);\n            }\n        };\n        getTokens();\n    }, [\n        props\n    ]);\n    async function createStakeDataFromStakeAddress(stake) {\n        let stakeData = \"\";\n        let assets = await getAssetsFromKoios(stake);\n        //no assets\n        if (assets.length == 0 || assets == null) {\n            stakeData = {\n                stake: stake,\n                tokenNumber: 0,\n                projectNumber: 0,\n                nfts: [],\n                fts: []\n            };\n        } else {\n            //assets, create new stake data\n            try {\n                // list of 'token' objects with assgined attributes\n                let _tokens = await createTokens(assets[0].asset_list);\n                // total number of tokens - used in summary\n                let _tokenNumber = _tokens.length;\n                // create list of policy Ids - with tokens sorted into policies\n                let _policies = groupTokensByPolicyId(_tokens);\n                // number of difference projects\n                // used in summary\n                let _policyNumber = Object.keys(_policies).length;\n                // splits policy list into two lists - nfts and fts, then combines into object = fungObj {nfts, fts}\n                let _fungObj = sortTokenFungibilities(_policies);\n                // wallet data object which is stored in local storage for quick retrieval\n                stakeData = {\n                    stake: stake,\n                    tokenNumber: _tokenNumber,\n                    projectNumber: _policyNumber,\n                    nfts: _fungObj.nfts,\n                    fts: _fungObj.fts\n                };\n            } catch (error) {\n                return null;\n            }\n        }\n        return stakeData;\n    }\n    // used when fetching handle address\n    async function getStakeFromAddressKoios(address) {\n        try {\n            const req = await fetch(\"https://api.koios.rest/api/v0/address_info\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    \"_addresses\": [\n                        address\n                    ]\n                })\n            });\n            const res = await req.json();\n            return res[0].stake_address;\n        } catch (error) {\n            return null;\n        }\n    }\n    // returns base address from handle\n    const getAddressFromHandle = async (handle)=>{\n        try {\n            let policyID = \"f0ff48bbb7bbe9d59a40f1ce90e9e9d0ff5002ec48f232b49ca0fb9a\";\n            // A blank Handle name should always be ignored.\n            if (handle.length === 0) {\n            // Handle error.\n            }\n            // Convert handleName to hex encoding.\n            let assetName = Buffer.from(handle).toString(\"hex\");\n            const data = await fetch(\"https://cardano-mainnet.blockfrost.io/api/v0/assets/\".concat(policyID).concat(assetName, \"/addresses\"), {\n                headers: {\n                    // Your Blockfrost API key\n                    project_id: \"mainnetoW61YYSiOoLSaNQ6dzTrkAG4azXVIrvh\",\n                    \"Content-Type\": \"application/json\"\n                }\n            }).then((res)=>res.json());\n            let stake = await getStakeFromAddressKoios(data[0].address);\n            return stake;\n        } catch (error) {\n            return null;\n        }\n    };\n    // no asset limit on how many assets gets returned on one request\n    // koios, blockfrost is limited by 100 results per page\n    async function getAssetsFromKoios(stakeAddress) {\n        try {\n            const req = await fetch(\"https://api.koios.rest/api/v0/account_assets\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    \"_stake_addresses\": [\n                        stakeAddress\n                    ]\n                })\n            });\n            const res = await req.json();\n            return res;\n        } catch (error) {\n            return null;\n        }\n    }\n    // creates a list of 'token' objects and sorts them by price\n    // token (asset_name, quantity, policy, metadata, prices, current (price))\n    async function createTokens(assets) {\n        const _tokens = [];\n        for(let i = 0; i < assets.length; i++){\n            setLoadingInfo(\"Loading tokens: \" + i + \" of \" + assets.length);\n            let token = new _token__WEBPACK_IMPORTED_MODULE_2__[\"default\"](assets[i].asset_name, assets[i].policy_id, assets[i].quantity);\n            // return data under 'onchain_metadata' or 'metadata'\n            token.metadata = await token.getMetadata();\n            // returns price data if available on CoinGecko\n            let prices = await token.getPrice();\n            if (prices != \"\") {\n                token.current = prices.current;\n                token.prices = prices;\n            } else {\n                token.prices = \"\";\n                token.current = -1;\n            }\n            //fetch  ipfs image from metadatat\n            if (token.metadata != null) {\n                let ipfs = token.getIpfsFromMetadata();\n                token.ipfs = ipfs;\n                _tokens.push(token);\n            }\n        }\n        // list of 'token' objects sorted by price attribute\n        let priceSorted = sortByPrice(_tokens);\n        return priceSorted;\n    }\n    // groups list of token objects by policy Id\n    function groupTokensByPolicyId(tokenList) {\n        const policyList = {};\n        for(const token in tokenList){\n            const policyId = tokenList[token].policy_id;\n            if (policyId in policyList) {\n                policyList[policyId].push(tokenList[token]);\n            } else {\n                policyList[policyId] = [\n                    tokenList[token]\n                ];\n            }\n        }\n        const keys = Object.keys(policyList);\n        //sort policy list by collection number\n        const values = Object.values(policyList);\n        values.sort((a, b)=>a.length - b.length).reverse();\n        const _sorted = {};\n        for(let i = 0; i < keys.length; i++){\n            _sorted[keys[i]] = values[i];\n        }\n        return _sorted;\n    }\n    // sort tokens by price\n    function sortByPrice(list) {\n        return list.sort((a, b)=>a.current - b.current);\n    }\n    // splits token by whether quantity is 1 or not (fungibility)\n    // returns object of two lists - fts and nfts\n    function sortTokenFungibilities(policies) {\n        let poly = Object.keys(policies);\n        let _nfts = [];\n        let _fts = [];\n        for (const element of poly){\n            let p = policies[element][0];\n            if (p.quantity == 1) {\n                _nfts.push(policies[element]);\n            } else {\n                _fts.push(policies[element]);\n            }\n        }\n        return {\n            nfts: _nfts,\n            fts: _fts\n        };\n    }\n    // displays while token data is being fetched\n    if (isLoading == \"fetching\") {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"loading-symbol\",\n                    style: {\n                        visibility: isVisible ? \"visible\" : \"hidden\"\n                    }\n                }, void 0, false, {\n                    fileName: \"/Users/nathan/Desktop/explorer/src/pages/walletData.js\",\n                    lineNumber: 281,\n                    columnNumber: 7\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                    className: \"loading-info\",\n                    children: loadingInfo\n                }, void 0, false, {\n                    fileName: \"/Users/nathan/Desktop/explorer/src/pages/walletData.js\",\n                    lineNumber: 282,\n                    columnNumber: 7\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/nathan/Desktop/explorer/src/pages/walletData.js\",\n            lineNumber: 279,\n            columnNumber: 12\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            visibility: isVisibleGrid ? \"visible\" : \"hidden\"\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_tokens__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n            tokens: stakeData\n        }, void 0, false, {\n            fileName: \"/Users/nathan/Desktop/explorer/src/pages/walletData.js\",\n            lineNumber: 288,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/nathan/Desktop/explorer/src/pages/walletData.js\",\n        lineNumber: 287,\n        columnNumber: 5\n    }, this);\n}\n_s(WalletData, \"YikdWWCWZ5591xTXOh1G/YmrZzU=\");\n_c = WalletData;\n/* harmony default export */ __webpack_exports__[\"default\"] = (WalletData);\nvar _c;\n$RefreshReg$(_c, \"WalletData\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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K0RBQWVBLFVBQVVBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3BhZ2VzL3dhbGxldERhdGEuanM/ZDY5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgVG9rZW4gZnJvbSBcIi4vdG9rZW5cIjtcbmltcG9ydCBOZnRzIGZyb20gXCIuL25mdHNcIjtcbmltcG9ydCBGdHMgZnJvbSBcIi4vZnRzXCI7XG5pbXBvcnQgVG9rZW5zIGZyb20gXCIuL3Rva2Vuc1wiO1xuaW1wb3J0IHsgaGVhZGVycyB9IGZyb20gXCJuZXh0LmNvbmZpZ1wiO1xuXG5cbmZ1bmN0aW9uIFdhbGxldERhdGEgKHByb3BzKSB7XG4gIGNvbnN0IFtpc1Zpc2libGVHcmlkLCBzZXRJc1Zpc2libGVHcmlkXSA9IHVzZVN0YXRlKCk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldGlzTG9hZGluZ10gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2lzVmlzaWJsZSwgc2V0SXNWaXNpYmxlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2xvYWRpbmdJbmZvLCBzZXRMb2FkaW5nSW5mb10gPSB1c2VTdGF0ZSgpO1xuICBjb25zdCBbc3Rha2VEYXRhLCBzZXRTdGFrZURhdGFdID0gdXNlU3RhdGUoe3N0YWtlOiBudWxsLCB0b2tlbk51bWJlcjogbnVsbCwgcHJvamVjdE51bWJlcjogbnVsbCwgbmZ0czogbnVsbCwgZnRzOiBudWxsfSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBnZXRUb2tlbnMgPSBhc3luYyAoKSA9PntcblxuICAgICAgaWYocHJvcHMuc3Rha2VBZGRyZXNzID09IG51bGwpe1xuICAgICAgICAvL2Jhc2VcbiAgICAgIH1cbiAgICAgIGVsc2V7XG5cbiAgICAgICAgLy9sb2FkaW5nIGljb25cbiAgICAgICAgc2V0aXNMb2FkaW5nKCdmZXRjaGluZycpO1xuICAgICAgICBzZXRJc1Zpc2libGVHcmlkKGZhbHNlKTtcbiAgICAgICAgc2V0SXNWaXNpYmxlKHRydWUpO1xuXG4gICAgICAgIC8vIHByb3BzIHBhc3NlZCBmcm9tIFtzdGFrZV0uanNcbiAgICAgICAgbGV0IHN0YWtlQWRkcmVzcyA9IHByb3BzLnN0YWtlQWRkcmVzcztcblxuICAgICAgICAvLyBjaGVjayBpZiBzdGFrZSBpcyBhIGhhbmRsZVxuICAgICAgICAvLyB0aGVuIGdldCBiYXNlIGFkZHJlc3MgdGhlbiBzdGFrZSBhZGRyZXNzIGZyb20gdGhhdCBoYW5kbGVcbiAgICAgICAgaWYoc3Rha2VBZGRyZXNzLnN0YXJ0c1dpdGgoJyQnKSl7XG4gICAgICAgICAgbGV0IHN0YWtlID0gYXdhaXQgZ2V0QWRkcmVzc0Zyb21IYW5kbGUoc3Rha2VBZGRyZXNzLnNsaWNlKDEpKTtcbiAgICAgICAgICBpZihzdGFrZSAhPSBudWxsKXtcbiAgICAgICAgICAgIHN0YWtlQWRkcmVzcyA9IHN0YWtlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3dhbGxldCBlcnJvcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIHdhbGxldCBpbmZvcm1hdGlvbiBpbiBsb2NhbCBzdG9yYWdlXG4gICAgICAgIGxldCBzdGFrZURhdGEgPSAnJztcblxuICAgICAgICAvL2lmIHN0YWtlIGRhdGEgZXhpc3QgaW4gc3RvcmFnZSAtLSBnZXQgaXRcbiAgICAgICAgaWYobG9jYWxTdG9yYWdlLmdldEl0ZW0oc3Rha2VBZGRyZXNzKSl7XG4gICAgICAgICAgc3Rha2VEYXRhID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShzdGFrZUFkZHJlc3MpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgbm8gc3RvcmVkIGRhdGEsIGNyZWF0ZSBuZXcgYW5kIHN0b3JlIGl0IHdpdGggc3Rha2UgYWRkcmVzcyBhcyBrZXlcbiAgICAgICAgZWxzZXtcbiAgICAgICAgICBzdGFrZURhdGEgPSBhd2FpdCBjcmVhdGVTdGFrZURhdGFGcm9tU3Rha2VBZGRyZXNzKHN0YWtlQWRkcmVzcyk7XG5cbiAgICAgICAgICBpZihzdGFrZURhdGEgIT0gbnVsbCl7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShzdGFrZUFkZHJlc3MsIEpTT04uc3RyaW5naWZ5KHN0YWtlRGF0YSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxvYWRpbmcgaWNvblxuICAgICAgICBzZXRTdGFrZURhdGEoc3Rha2VEYXRhKTtcbiAgICAgICAgc2V0aXNMb2FkaW5nKCdkb25lJyk7XG4gICAgICAgIHNldElzVmlzaWJsZShmYWxzZSk7XG4gICAgICAgIHNldElzVmlzaWJsZUdyaWQodHJ1ZSk7XG5cbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0VG9rZW5zKCk7XG4gIH0sIFtwcm9wc10pO1xuXG5cblxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVTdGFrZURhdGFGcm9tU3Rha2VBZGRyZXNzKHN0YWtlKXtcblxuICAgIGxldCBzdGFrZURhdGEgPSAnJztcbiAgICBsZXQgYXNzZXRzID0gYXdhaXQgZ2V0QXNzZXRzRnJvbUtvaW9zKHN0YWtlKTtcblxuICAgIC8vbm8gYXNzZXRzXG4gICAgaWYoYXNzZXRzLmxlbmd0aCA9PSAwIHx8IGFzc2V0cyA9PSBudWxsKXtcbiAgICAgIHN0YWtlRGF0YSA9IHtzdGFrZSA6IHN0YWtlLCB0b2tlbk51bWJlcjogMCwgcHJvamVjdE51bWJlcjowLCBuZnRzOiBbXSwgZnRzIDogW119O1xuICAgIH1cbiAgICBlbHNle1xuICAgICAgLy9hc3NldHMsIGNyZWF0ZSBuZXcgc3Rha2UgZGF0YVxuICAgICAgdHJ5e1xuICAgICAgICAvLyBsaXN0IG9mICd0b2tlbicgb2JqZWN0cyB3aXRoIGFzc2dpbmVkIGF0dHJpYnV0ZXNcbiAgICAgICAgbGV0IF90b2tlbnMgPSBhd2FpdCBjcmVhdGVUb2tlbnMoYXNzZXRzWzBdLmFzc2V0X2xpc3QpO1xuXG4gICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiB0b2tlbnMgLSB1c2VkIGluIHN1bW1hcnlcbiAgICAgICAgbGV0IF90b2tlbk51bWJlciA9IF90b2tlbnMubGVuZ3RoO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBsaXN0IG9mIHBvbGljeSBJZHMgLSB3aXRoIHRva2VucyBzb3J0ZWQgaW50byBwb2xpY2llc1xuICAgICAgICBsZXQgX3BvbGljaWVzID0gZ3JvdXBUb2tlbnNCeVBvbGljeUlkKF90b2tlbnMpO1xuXG4gICAgICAgIC8vIG51bWJlciBvZiBkaWZmZXJlbmNlIHByb2plY3RzXG4gICAgICAgIC8vIHVzZWQgaW4gc3VtbWFyeVxuICAgICAgICBsZXQgX3BvbGljeU51bWJlciA9IChPYmplY3Qua2V5cyhfcG9saWNpZXMpLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gc3BsaXRzIHBvbGljeSBsaXN0IGludG8gdHdvIGxpc3RzIC0gbmZ0cyBhbmQgZnRzLCB0aGVuIGNvbWJpbmVzIGludG8gb2JqZWN0ID0gZnVuZ09iaiB7bmZ0cywgZnRzfVxuICAgICAgICBsZXQgX2Z1bmdPYmogPSBzb3J0VG9rZW5GdW5naWJpbGl0aWVzKF9wb2xpY2llcyk7XG5cbiAgICAgICAgLy8gd2FsbGV0IGRhdGEgb2JqZWN0IHdoaWNoIGlzIHN0b3JlZCBpbiBsb2NhbCBzdG9yYWdlIGZvciBxdWljayByZXRyaWV2YWxcbiAgICAgICAgc3Rha2VEYXRhID0ge3N0YWtlOiBzdGFrZSwgdG9rZW5OdW1iZXI6IF90b2tlbk51bWJlciwgcHJvamVjdE51bWJlcjogX3BvbGljeU51bWJlciwgbmZ0czogX2Z1bmdPYmoubmZ0cywgZnRzOiBfZnVuZ09iai5mdHN9O1xuXG4gICAgICB9Y2F0Y2goZXJyb3Ipe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YWtlRGF0YTtcblxuICB9XG5cbiAgLy8gdXNlZCB3aGVuIGZldGNoaW5nIGhhbmRsZSBhZGRyZXNzXG4gIGFzeW5jIGZ1bmN0aW9uIGdldFN0YWtlRnJvbUFkZHJlc3NLb2lvcyhhZGRyZXNzKXtcbiAgICB0cnl7XG4gICAgICBjb25zdCByZXEgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9hcGkua29pb3MucmVzdC9hcGkvdjAvYWRkcmVzc19pbmZvJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIFwiX2FkZHJlc3Nlc1wiOiBbIGFkZHJlc3NcbiAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCByZXEuanNvbigpO1xuICAgICAgcmV0dXJuIHJlc1swXS5zdGFrZV9hZGRyZXNzO1xuICAgIH1jYXRjaChlcnJvcil7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgfVxuXG4gIC8vIHJldHVybnMgYmFzZSBhZGRyZXNzIGZyb20gaGFuZGxlXG4gIGNvbnN0IGdldEFkZHJlc3NGcm9tSGFuZGxlID0gYXN5bmMgKGhhbmRsZSkgPT4ge1xuICAgIHRyeXtcbiAgICAgIGxldCBwb2xpY3lJRCA9ICdmMGZmNDhiYmI3YmJlOWQ1OWE0MGYxY2U5MGU5ZTlkMGZmNTAwMmVjNDhmMjMyYjQ5Y2EwZmI5YSc7XG4gICAgXG4gICAgICAvLyBBIGJsYW5rIEhhbmRsZSBuYW1lIHNob3VsZCBhbHdheXMgYmUgaWdub3JlZC5cbiAgICAgIGlmIChoYW5kbGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIEhhbmRsZSBlcnJvci5cbiAgICAgIH1cbiAgICBcbiAgICAgIC8vIENvbnZlcnQgaGFuZGxlTmFtZSB0byBoZXggZW5jb2RpbmcuXG4gICAgICBsZXQgYXNzZXROYW1lID0gQnVmZmVyLmZyb20oaGFuZGxlKS50b1N0cmluZygnaGV4Jyk7XG4gICAgXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZmV0Y2goXG4gICAgICAgIGBodHRwczovL2NhcmRhbm8tbWFpbm5ldC5ibG9ja2Zyb3N0LmlvL2FwaS92MC9hc3NldHMvJHtwb2xpY3lJRH0ke2Fzc2V0TmFtZX0vYWRkcmVzc2VzYCxcbiAgICAgICAge1xuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIC8vIFlvdXIgQmxvY2tmcm9zdCBBUEkga2V5XG4gICAgICAgICAgICBwcm9qZWN0X2lkOiAnbWFpbm5ldG9XNjFZWVNpT29MU2FOUTZkelRya0FHNGF6WFZJcnZoJyxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICkudGhlbihyZXMgPT4gcmVzLmpzb24oKSk7XG4gICAgICBcbiAgICAgIGxldCBzdGFrZSA9IGF3YWl0IGdldFN0YWtlRnJvbUFkZHJlc3NLb2lvcyhkYXRhWzBdLmFkZHJlc3MpO1xuICAgICAgcmV0dXJuIHN0YWtlO1xuICAgIH1jYXRjaChlcnJvcil7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgfVxuXG4gIC8vIG5vIGFzc2V0IGxpbWl0IG9uIGhvdyBtYW55IGFzc2V0cyBnZXRzIHJldHVybmVkIG9uIG9uZSByZXF1ZXN0XG4gIC8vIGtvaW9zLCBibG9ja2Zyb3N0IGlzIGxpbWl0ZWQgYnkgMTAwIHJlc3VsdHMgcGVyIHBhZ2VcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0QXNzZXRzRnJvbUtvaW9zKHN0YWtlQWRkcmVzcyl7XG4gICAgdHJ5e1xuICAgICAgY29uc3QgcmVxID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vYXBpLmtvaW9zLnJlc3QvYXBpL3YwL2FjY291bnRfYXNzZXRzJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIFwiX3N0YWtlX2FkZHJlc3Nlc1wiOiBbXG4gICAgICAgICAgICBzdGFrZUFkZHJlc3NcbiAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzID0gYXdhaXQgcmVxLmpzb24oKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfWNhdGNoKGVycm9yKXtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICB9XG5cbiAgLy8gY3JlYXRlcyBhIGxpc3Qgb2YgJ3Rva2VuJyBvYmplY3RzIGFuZCBzb3J0cyB0aGVtIGJ5IHByaWNlXG4gIC8vIHRva2VuIChhc3NldF9uYW1lLCBxdWFudGl0eSwgcG9saWN5LCBtZXRhZGF0YSwgcHJpY2VzLCBjdXJyZW50IChwcmljZSkpXG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRva2Vucyhhc3NldHMpe1xuICAgIGNvbnN0IF90b2tlbnMgPSBbXTtcblxuICAgIGZvcihsZXQgaSA9MDsgaTxhc3NldHMubGVuZ3RoO2krKyl7XG4gICAgICBzZXRMb2FkaW5nSW5mbygnTG9hZGluZyB0b2tlbnM6ICcraSArICcgb2YgJyArYXNzZXRzLmxlbmd0aClcbiAgICAgIGxldCB0b2tlbiA9IG5ldyBUb2tlbihhc3NldHNbaV0uYXNzZXRfbmFtZSwgYXNzZXRzW2ldLnBvbGljeV9pZCwgYXNzZXRzW2ldLnF1YW50aXR5KTtcblxuICAgICAgLy8gcmV0dXJuIGRhdGEgdW5kZXIgJ29uY2hhaW5fbWV0YWRhdGEnIG9yICdtZXRhZGF0YSdcbiAgICAgIHRva2VuLm1ldGFkYXRhID0gYXdhaXQgdG9rZW4uZ2V0TWV0YWRhdGEoKTtcblxuICAgICAgLy8gcmV0dXJucyBwcmljZSBkYXRhIGlmIGF2YWlsYWJsZSBvbiBDb2luR2Vja29cbiAgICAgIGxldCBwcmljZXMgPSBhd2FpdCB0b2tlbi5nZXRQcmljZSgpO1xuXG4gICAgICBpZihwcmljZXMgIT0gJycpe1xuICAgICAgICB0b2tlbi5jdXJyZW50ID0gcHJpY2VzLmN1cnJlbnQ7XG4gICAgICAgIHRva2VuLnByaWNlcyA9IHByaWNlcztcbiAgICAgIH1cbiAgICAgIGVsc2V7XG4gICAgICAgIHRva2VuLnByaWNlcyA9ICcnO1xuICAgICAgICB0b2tlbi5jdXJyZW50ID0gLTE7XG4gICAgICB9XG5cbiAgICAgIC8vZmV0Y2ggIGlwZnMgaW1hZ2UgZnJvbSBtZXRhZGF0YXRcbiAgICAgIGlmKHRva2VuLm1ldGFkYXRhICE9IG51bGwpe1xuICAgICAgICBsZXQgaXBmcyA9IHRva2VuLmdldElwZnNGcm9tTWV0YWRhdGEoKTtcbiAgICAgICAgdG9rZW4uaXBmcyA9IGlwZnM7XG4gICAgICAgX3Rva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBsaXN0IG9mICd0b2tlbicgb2JqZWN0cyBzb3J0ZWQgYnkgcHJpY2UgYXR0cmlidXRlXG4gICAgbGV0IHByaWNlU29ydGVkID0gc29ydEJ5UHJpY2UoX3Rva2Vucyk7XG4gICAgcmV0dXJuIHByaWNlU29ydGVkO1xuICB9XG5cbiAgLy8gZ3JvdXBzIGxpc3Qgb2YgdG9rZW4gb2JqZWN0cyBieSBwb2xpY3kgSWRcbiAgZnVuY3Rpb24gZ3JvdXBUb2tlbnNCeVBvbGljeUlkKHRva2VuTGlzdCl7XG5cbiAgICBjb25zdCBwb2xpY3lMaXN0ID0ge307XG4gICAgZm9yKGNvbnN0IHRva2VuIGluIHRva2VuTGlzdCl7XG4gICAgICBjb25zdCBwb2xpY3lJZCA9IHRva2VuTGlzdFt0b2tlbl0ucG9saWN5X2lkO1xuICAgICAgXG4gICAgICBpZihwb2xpY3lJZCBpbiBwb2xpY3lMaXN0KXtcbiAgICAgICAgcG9saWN5TGlzdFtwb2xpY3lJZF0ucHVzaCh0b2tlbkxpc3RbdG9rZW5dKTtcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgcG9saWN5TGlzdFtwb2xpY3lJZF0gPSBbdG9rZW5MaXN0W3Rva2VuXV07XG4gICAgICB9XG5cbiAgICB9XG4gICAgY29uc3Qga2V5cz0gT2JqZWN0LmtleXMocG9saWN5TGlzdCk7XG5cbiAgICAvL3NvcnQgcG9saWN5IGxpc3QgYnkgY29sbGVjdGlvbiBudW1iZXJcbiAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKHBvbGljeUxpc3QpO1xuICAgIHZhbHVlcy5zb3J0KChhLGIpID0+IGEubGVuZ3RoIC0gYi5sZW5ndGgpLnJldmVyc2UoKTtcbiAgICBjb25zdCBfc29ydGVkID0ge307XG4gICAgZm9yIChsZXQgaT0wO2k8a2V5cy5sZW5ndGg7aSsrKXtcbiAgICAgIF9zb3J0ZWRba2V5c1tpXV0gPSB2YWx1ZXMgW2ldO1xuICAgIH1cbiAgICByZXR1cm4gX3NvcnRlZDtcbiAgfVxuXG4gIC8vIHNvcnQgdG9rZW5zIGJ5IHByaWNlXG4gIGZ1bmN0aW9uIHNvcnRCeVByaWNlKGxpc3QpIHtcbiAgICByZXR1cm4gbGlzdC5zb3J0KChhLCBiKSA9PiBhLmN1cnJlbnQgLSBiLmN1cnJlbnQpO1xuICB9XG5cbiAgLy8gc3BsaXRzIHRva2VuIGJ5IHdoZXRoZXIgcXVhbnRpdHkgaXMgMSBvciBub3QgKGZ1bmdpYmlsaXR5KVxuICAvLyByZXR1cm5zIG9iamVjdCBvZiB0d28gbGlzdHMgLSBmdHMgYW5kIG5mdHNcbiAgZnVuY3Rpb24gc29ydFRva2VuRnVuZ2liaWxpdGllcyhwb2xpY2llcyl7XG4gICAgbGV0IHBvbHkgPSBPYmplY3Qua2V5cyhwb2xpY2llcyk7XG4gICAgbGV0IF9uZnRzID0gW107XG4gICAgbGV0IF9mdHMgPSBbXTtcbiAgICBmb3IoY29uc3QgZWxlbWVudCBvZiBwb2x5KXtcbiAgICAgIGxldCBwID0gcG9saWNpZXNbZWxlbWVudF1bMF07XG4gICAgICBpZihwLnF1YW50aXR5ID09IDEpe1xuICAgICAgICBfbmZ0cy5wdXNoKHBvbGljaWVzW2VsZW1lbnRdKTtcbiAgICAgIH1cbiAgICAgIGVsc2V7XG4gICAgICAgIF9mdHMucHVzaChwb2xpY2llc1tlbGVtZW50XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7bmZ0cyA6IF9uZnRzLCBmdHMgOiBfZnRzfTtcbiAgfVxuXG4gIC8vIGRpc3BsYXlzIHdoaWxlIHRva2VuIGRhdGEgaXMgYmVpbmcgZmV0Y2hlZFxuICBpZihpc0xvYWRpbmcgPT0gJ2ZldGNoaW5nJyl7XG4gICAgcmV0dXJuIDxkaXY+XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwibG9hZGluZy1zeW1ib2xcIiBzdHlsZT17eyB2aXNpYmlsaXR5OiBpc1Zpc2libGUgPyAndmlzaWJsZScgOiAnaGlkZGVuJyB9fT48L2Rpdj5cbiAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJsb2FkaW5nLWluZm9cIj57bG9hZGluZ0luZm99PC9sYWJlbD5cbiAgICA8L2Rpdj5cbiAgfVxuXG4gIHJldHVybihcbiAgICA8ZGl2IHN0eWxlPXt7IHZpc2liaWxpdHk6IGlzVmlzaWJsZUdyaWQgPyAndmlzaWJsZScgOiAnaGlkZGVuJyB9fT5cbiAgICAgIDxUb2tlbnMgdG9rZW5zID0ge3N0YWtlRGF0YX0vPlxuICAgIDwvZGl2PlxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBXYWxsZXREYXRhO1xuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiVG9rZW4iLCJOZnRzIiwiRnRzIiwiVG9rZW5zIiwiaGVhZGVycyIsIldhbGxldERhdGEiLCJwcm9wcyIsImlzVmlzaWJsZUdyaWQiLCJzZXRJc1Zpc2libGVHcmlkIiwiaXNMb2FkaW5nIiwic2V0aXNMb2FkaW5nIiwiaXNWaXNpYmxlIiwic2V0SXNWaXNpYmxlIiwibG9hZGluZ0luZm8iLCJzZXRMb2FkaW5nSW5mbyIsInN0YWtlRGF0YSIsInNldFN0YWtlRGF0YSIsInN0YWtlIiwidG9rZW5OdW1iZXIiLCJwcm9qZWN0TnVtYmVyIiwibmZ0cyIsImZ0cyIsImdldFRva2VucyIsInN0YWtlQWRkcmVzcyIsInN0YXJ0c1dpdGgiLCJnZXRBZGRyZXNzRnJvbUhhbmRsZSIsInNsaWNlIiwiY29uc29sZSIsImxvZyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJKU09OIiwicGFyc2UiLCJjcmVhdGVTdGFrZURhdGFGcm9tU3Rha2VBZGRyZXNzIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImFzc2V0cyIsImdldEFzc2V0c0Zyb21Lb2lvcyIsImxlbmd0aCIsIl90b2tlbnMiLCJjcmVhdGVUb2tlbnMiLCJhc3NldF9saXN0IiwiX3Rva2VuTnVtYmVyIiwiX3BvbGljaWVzIiwiZ3JvdXBUb2tlbnNCeVBvbGljeUlkIiwiX3BvbGljeU51bWJlciIsIk9iamVjdCIsImtleXMiLCJfZnVuZ09iaiIsInNvcnRUb2tlbkZ1bmdpYmlsaXRpZXMiLCJlcnJvciIsImdldFN0YWtlRnJvbUFkZHJlc3NLb2lvcyIsImFkZHJlc3MiLCJyZXEiLCJmZXRjaCIsIm1ldGhvZCIsImJvZHkiLCJyZXMiLCJqc29uIiwic3Rha2VfYWRkcmVzcyIsImhhbmRsZSIsInBvbGljeUlEIiwiYXNzZXROYW1lIiwiQnVmZmVyIiwiZnJvbSIsInRvU3RyaW5nIiwiZGF0YSIsInByb2plY3RfaWQiLCJ0aGVuIiwiaSIsInRva2VuIiwiYXNzZXRfbmFtZSIsInBvbGljeV9pZCIsInF1YW50aXR5IiwibWV0YWRhdGEiLCJnZXRNZXRhZGF0YSIsInByaWNlcyIsImdldFByaWNlIiwiY3VycmVudCIsImlwZnMiLCJnZXRJcGZzRnJvbU1ldGFkYXRhIiwicHVzaCIsInByaWNlU29ydGVkIiwic29ydEJ5UHJpY2UiLCJ0b2tlbkxpc3QiLCJwb2xpY3lMaXN0IiwicG9saWN5SWQiLCJ2YWx1ZXMiLCJzb3J0IiwiYSIsImIiLCJyZXZlcnNlIiwiX3NvcnRlZCIsImxpc3QiLCJwb2xpY2llcyIsInBvbHkiLCJfbmZ0cyIsIl9mdHMiLCJlbGVtZW50IiwicCIsImRpdiIsImNsYXNzTmFtZSIsInN0eWxlIiwidmlzaWJpbGl0eSIsImxhYmVsIiwidG9rZW5zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/pages/walletData.js\n"));

/***/ })

});