"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/[query]",{

/***/ "./pages/token.js":
/*!************************!*\
  !*** ./pages/token.js ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Token; }\n/* harmony export */ });\nconst blockfrostFetch = async (endpoint)=>{\n    const baseURL = \"https://cardano-mainnet.blockfrost.io/api/v0/\";\n    const projectId = \"mainnetoW61YYSiOoLSaNQ6dzTrkAG4azXVIrvh\";\n    const response = await fetch(baseURL + endpoint, {\n        headers: {\n            project_id: projectId,\n            \"cache-control\": \"max-age=31536000\"\n        }\n    });\n    if (!response.ok) {\n        throw new Error(\"Failed to fetch data from Blockfrost API: \".concat(response.statusText));\n    }\n    return await response.json();\n};\n// if metadata has been fetched\n// find the ipfs link under 'image' metadata tag and store it\nconst getIpfsFromMetadata = (metadata)=>{\n    const keys = Object.keys(metadata);\n    const values = Object.values(metadata);\n    let ipfs = \"\";\n    for(let i = 0; i < keys.length; i++){\n        if (keys[i] == \"image\") {\n            ipfs = values[i];\n        }\n        // fungible tokens will have a 'logo' instead of 'image' tag\n        if (keys[i] == \"logo\") {\n            ipfs = \"data:image/png;base64,\" + values[i];\n        }\n    }\n    // convert all ipfs formats to the a searchable format that can be fetched in a <img> tag\n    try {\n        // links are sometimes stored in arrays\n        // this finds ipfs links in the array\n        if (Array.isArray(ipfs)) {\n            let newipfs = \"\";\n            for (const element of ipfs){\n                newipfs = newipfs + element;\n            }\n            if (newipfs.startsWith(\"ba\")) {\n                newipfs = \"http://dweb.link/ipfs/\" + ipfs;\n                newipfs = newipfs.replace(/,/g, \"\");\n            }\n            return newipfs;\n        }\n        // normal ipfs in image tags\n        if (ipfs.startsWith(\"ipfs://\")) {\n            ipfs = ipfs.slice(7);\n            if (ipfs.startsWith(\"ipfs/\")) {\n                ipfs = ipfs.slice(5);\n            }\n            ipfs = \"http://dweb.link/ipfs/\" + ipfs;\n        } else if (ipfs.startsWith(\"ipfs/\")) {\n            ipfs = ipfs.slice(5);\n            ipfs = \"http://dweb.link/ipfs/\" + ipfs;\n        } else if (ipfs.startsWith(\"Qm\")) {\n            ipfs = \"http://dweb.link/ipfs/\" + ipfs;\n        }\n    } catch (e) {\n        return null;\n    }\n    return ipfs;\n};\nclass Token {\n    async fetchTokenData() {\n        try {\n            const assetId = this.policy_id + this.asset_name;\n            const [metadataRes, txsRes] = await Promise.all([\n                blockfrostFetch(\"assets/\".concat(assetId)),\n                blockfrostFetch(\"assets/\".concat(assetId, \"/transactions\"))\n            ]);\n            this.onchain_metadata = metadataRes.onchain_metadata || null;\n            this.metadata = metadataRes.metadata || null;\n            this.txs = txsRes || null;\n            this.ipfs = getIpfsFromMetadata(this.onchain_metadata || {});\n        } catch (e) {}\n    }\n    async getPrice() {\n        if (this.quantity === 1) {\n            console.log(\"Not fungible\");\n            return;\n        }\n        try {\n            var _this_metadata;\n            const request = await fetch(\"/coin-gecko.json\");\n            const geckoData = await request.json();\n            const ticker = (_this_metadata = this.metadata) === null || _this_metadata === void 0 ? void 0 : _this_metadata.ticker;\n            if (!ticker) {\n                return;\n            }\n            const foundGeckoCoin = geckoData.find((item)=>item.symbol === ticker.toLowerCase());\n            if (!foundGeckoCoin) {\n                return;\n            }\n            const req = await fetch(\"https://api.coingecko.com/api/v3/coins/\".concat(foundGeckoCoin.id));\n            const res = await req.json();\n            if (res.asset_platform_id === \"cardano\") {\n                const priceData = res.market_data;\n                this.prices = {\n                    current: priceData.current_price.usd.toFixed(2),\n                    change24h: priceData.price_change_percentage_24h.toFixed(2),\n                    change7d: priceData.price_change_percentage_7d.toFixed(2),\n                    change30d: priceData.price_change_percentage_30d.toFixed(2),\n                    change1y: priceData.price_change_percentage_1y.toFixed(2)\n                };\n            }\n        } catch (error) {\n            console.error(\"Error fetching price data:\", error);\n        }\n    }\n    constructor(asset_name, policy_id, quantity){\n        this.asset_name = asset_name;\n        this.policy_id = policy_id;\n        this.quantity = quantity;\n        this.onchain_metadata = null;\n        this.metadata = null;\n        this.txs = null;\n        this.ipfs = null;\n        this.prices = null;\n        this.image = null;\n    }\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy90b2tlbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsa0JBQWtCLE9BQU9DLFdBQWE7SUFDMUMsTUFBTUMsVUFBVTtJQUNoQixNQUFNQyxZQUFZO0lBQ2xCLE1BQU1DLFdBQVcsTUFBTUMsTUFBTUgsVUFBVUQsVUFBVTtRQUMvQ0ssU0FBUztZQUNQQyxZQUFZSjtZQUNaLGlCQUFpQjtRQUNuQjtJQUNGO0lBRUEsSUFBSSxDQUFDQyxTQUFTSSxFQUFFLEVBQUU7UUFDaEIsTUFBTSxJQUFJQyxNQUFNLDZDQUFpRSxPQUFwQkwsU0FBU00sVUFBVSxHQUFJO0lBQ3RGLENBQUM7SUFDRCxPQUFPLE1BQU1OLFNBQVNPLElBQUk7QUFDNUI7QUFFSSwrQkFBK0I7QUFDL0IsNkRBQTZEO0FBQ2pFLE1BQU1DLHNCQUFzQixDQUFDQyxXQUFZO0lBQ25DLE1BQU1DLE9BQU9DLE9BQU9ELElBQUksQ0FBQ0Q7SUFDekIsTUFBTUcsU0FBU0QsT0FBT0MsTUFBTSxDQUFDSDtJQUM3QixJQUFJSSxPQUFPO0lBQ1gsSUFBSSxJQUFJQyxJQUFFLEdBQUVBLElBQUVKLEtBQUtLLE1BQU0sRUFBQ0QsSUFBSTtRQUc1QixJQUFHSixJQUFJLENBQUNJLEVBQUUsSUFBSSxTQUFRO1lBQ3BCRCxPQUFPRCxNQUFNLENBQUNFLEVBQUU7UUFDbEIsQ0FBQztRQUVELDREQUE0RDtRQUM1RCxJQUFHSixJQUFJLENBQUNJLEVBQUUsSUFBSSxRQUFPO1lBQ25CRCxPQUFPLDJCQUF5QkQsTUFBTSxDQUFDRSxFQUFFO1FBQzNDLENBQUM7SUFDSDtJQUVBLHlGQUF5RjtJQUN6RixJQUFHO1FBRUQsdUNBQXVDO1FBQ3ZDLHFDQUFxQztRQUNyQyxJQUFHRSxNQUFNQyxPQUFPLENBQUNKLE9BQU07WUFDckIsSUFBSUssVUFBVTtZQUNkLEtBQUksTUFBTUMsV0FBV04sS0FBSztnQkFDeEJLLFVBQVVBLFVBQVVDO1lBQ3RCO1lBQ0EsSUFBR0QsUUFBUUUsVUFBVSxDQUFDLE9BQU07Z0JBQzFCRixVQUFVLDJCQUF5Qkw7Z0JBQ25DSyxVQUFVQSxRQUFRRyxPQUFPLENBQUMsTUFBTTtZQUNsQyxDQUFDO1lBQ0QsT0FBT0g7UUFDVCxDQUFDO1FBRUQsNEJBQTRCO1FBQzVCLElBQUdMLEtBQUtPLFVBQVUsQ0FBQyxZQUFXO1lBQzVCUCxPQUFPQSxLQUFLUyxLQUFLLENBQUM7WUFDbEIsSUFBR1QsS0FBS08sVUFBVSxDQUFDLFVBQVM7Z0JBQzFCUCxPQUFPQSxLQUFLUyxLQUFLLENBQUM7WUFDcEIsQ0FBQztZQUNEVCxPQUFPLDJCQUF5QkE7UUFDbEMsT0FDSyxJQUFHQSxLQUFLTyxVQUFVLENBQUMsVUFBUztZQUMvQlAsT0FBT0EsS0FBS1MsS0FBSyxDQUFDO1lBQ2xCVCxPQUFPLDJCQUF5QkE7UUFDbEMsT0FDSyxJQUFHQSxLQUFLTyxVQUFVLENBQUMsT0FBTTtZQUM1QlAsT0FBTywyQkFBeUJBO1FBQ2xDLENBQUM7SUFFSCxFQUFDLFVBQUs7UUFDSixPQUFPLElBQUk7SUFDYjtJQUNBLE9BQU9BO0FBRVQ7QUFJVyxNQUFNVTtJQWFuQixNQUFNQyxpQkFBaUI7UUFDckIsSUFBSTtZQUNGLE1BQU1DLFVBQVUsSUFBSSxDQUFDQyxTQUFTLEdBQUcsSUFBSSxDQUFDQyxVQUFVO1lBQ2hELE1BQU0sQ0FBQ0MsYUFBYUMsT0FBTyxHQUFHLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQztnQkFDOUNuQyxnQkFBZ0IsVUFBa0IsT0FBUjZCO2dCQUMxQjdCLGdCQUFnQixVQUFrQixPQUFSNkIsU0FBUTthQUNuQztZQUVELElBQUksQ0FBQ08sZ0JBQWdCLEdBQUdKLFlBQVlJLGdCQUFnQixJQUFJLElBQUk7WUFDNUQsSUFBSSxDQUFDdkIsUUFBUSxHQUFHbUIsWUFBWW5CLFFBQVEsSUFBSSxJQUFJO1lBQzVDLElBQUksQ0FBQ3dCLEdBQUcsR0FBR0osVUFBVSxJQUFJO1lBRXpCLElBQUksQ0FBQ2hCLElBQUksR0FBR0wsb0JBQW9CLElBQUksQ0FBQ3dCLGdCQUFnQixJQUFJLENBQUM7UUFDNUQsRUFBRSxVQUFLLENBQ1A7SUFDRjtJQUdBLE1BQU1FLFdBQVc7UUFDZixJQUFJLElBQUksQ0FBQ0MsUUFBUSxLQUFLLEdBQUc7WUFDdkJDLFFBQVFDLEdBQUcsQ0FBQztZQUNaO1FBQ0YsQ0FBQztRQUFBLElBQUk7Z0JBR1k7WUFGZixNQUFNQyxVQUFVLE1BQU1yQyxNQUFNO1lBQzVCLE1BQU1zQyxZQUFZLE1BQU1ELFFBQVEvQixJQUFJO1lBQ3BDLE1BQU1pQyxTQUFTLHNCQUFJLENBQUMvQixRQUFRLGNBQWIsb0RBQWUrQixNQUFNO1lBRXBDLElBQUksQ0FBQ0EsUUFBUTtnQkFDWDtZQUNGLENBQUM7WUFFRCxNQUFNQyxpQkFBaUJGLFVBQVVHLElBQUksQ0FBQ0MsQ0FBQUEsT0FBUUEsS0FBS0MsTUFBTSxLQUFLSixPQUFPSyxXQUFXO1lBQ2hGLElBQUksQ0FBQ0osZ0JBQWdCO2dCQUNuQjtZQUNGLENBQUM7WUFFRCxNQUFNSyxNQUFNLE1BQU03QyxNQUFNLDBDQUE0RCxPQUFsQndDLGVBQWVNLEVBQUU7WUFDbkYsTUFBTUMsTUFBTSxNQUFNRixJQUFJdkMsSUFBSTtZQUUxQixJQUFJeUMsSUFBSUMsaUJBQWlCLEtBQUssV0FBVztnQkFDdkMsTUFBTUMsWUFBWUYsSUFBSUcsV0FBVztnQkFDakMsSUFBSSxDQUFDQyxNQUFNLEdBQUc7b0JBQ1pDLFNBQVNILFVBQVVJLGFBQWEsQ0FBQ0MsR0FBRyxDQUFDQyxPQUFPLENBQUM7b0JBQzdDQyxXQUFXUCxVQUFVUSwyQkFBMkIsQ0FBQ0YsT0FBTyxDQUFDO29CQUN6REcsVUFBVVQsVUFBVVUsMEJBQTBCLENBQUNKLE9BQU8sQ0FBQztvQkFDdkRLLFdBQVdYLFVBQVVZLDJCQUEyQixDQUFDTixPQUFPLENBQUM7b0JBQ3pETyxVQUFVYixVQUFVYywwQkFBMEIsQ0FBQ1IsT0FBTyxDQUFDO2dCQUN6RDtZQUNGLENBQUM7UUFDSCxFQUFFLE9BQU9TLE9BQU87WUFDZDdCLFFBQVE2QixLQUFLLENBQUMsOEJBQThCQTtRQUM5QztJQUNGO0lBaEVBQyxZQUFZdkMsVUFBVSxFQUFFRCxTQUFTLEVBQUVTLFFBQVEsQ0FBRTtRQUMzQyxJQUFJLENBQUNSLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDRCxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ1MsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNILGdCQUFnQixHQUFHLElBQUk7UUFDNUIsSUFBSSxDQUFDdkIsUUFBUSxHQUFHLElBQUk7UUFDcEIsSUFBSSxDQUFDd0IsR0FBRyxHQUFHLElBQUk7UUFDZixJQUFJLENBQUNwQixJQUFJLEdBQUcsSUFBSTtRQUNoQixJQUFJLENBQUN1QyxNQUFNLEdBQUcsSUFBSTtRQUNsQixJQUFJLENBQUNlLEtBQUssR0FBRyxJQUFJO0lBQ25CO0FBdURGO0FBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvdG9rZW4uanM/ZjMzYSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBibG9ja2Zyb3N0RmV0Y2ggPSBhc3luYyAoZW5kcG9pbnQpID0+IHtcbiAgY29uc3QgYmFzZVVSTCA9ICdodHRwczovL2NhcmRhbm8tbWFpbm5ldC5ibG9ja2Zyb3N0LmlvL2FwaS92MC8nO1xuICBjb25zdCBwcm9qZWN0SWQgPSAnbWFpbm5ldG9XNjFZWVNpT29MU2FOUTZkelRya0FHNGF6WFZJcnZoJztcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChiYXNlVVJMICsgZW5kcG9pbnQsIHtcbiAgICBoZWFkZXJzOiB7XG4gICAgICBwcm9qZWN0X2lkOiBwcm9qZWN0SWQsXG4gICAgICAnY2FjaGUtY29udHJvbCc6ICdtYXgtYWdlPTMxNTM2MDAwJyxcbiAgICB9LFxuICB9KTtcblxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggZGF0YSBmcm9tIEJsb2NrZnJvc3QgQVBJOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbn07XG5cbiAgICAvLyBpZiBtZXRhZGF0YSBoYXMgYmVlbiBmZXRjaGVkXG4gICAgLy8gZmluZCB0aGUgaXBmcyBsaW5rIHVuZGVyICdpbWFnZScgbWV0YWRhdGEgdGFnIGFuZCBzdG9yZSBpdFxuY29uc3QgZ2V0SXBmc0Zyb21NZXRhZGF0YSA9IChtZXRhZGF0YSkgPT57XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobWV0YWRhdGEpO1xuICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhtZXRhZGF0YSk7XG4gICAgICBsZXQgaXBmcyA9IFwiXCI7XG4gICAgICBmb3IobGV0IGk9MDtpPGtleXMubGVuZ3RoO2krKyl7XG5cblxuICAgICAgICBpZihrZXlzW2ldID09IFwiaW1hZ2VcIil7XG4gICAgICAgICAgaXBmcyA9IHZhbHVlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gZnVuZ2libGUgdG9rZW5zIHdpbGwgaGF2ZSBhICdsb2dvJyBpbnN0ZWFkIG9mICdpbWFnZScgdGFnXG4gICAgICAgIGlmKGtleXNbaV0gPT0gXCJsb2dvXCIpe1xuICAgICAgICAgIGlwZnMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxcIit2YWx1ZXNbaV1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjb252ZXJ0IGFsbCBpcGZzIGZvcm1hdHMgdG8gdGhlIGEgc2VhcmNoYWJsZSBmb3JtYXQgdGhhdCBjYW4gYmUgZmV0Y2hlZCBpbiBhIDxpbWc+IHRhZ1xuICAgICAgdHJ5e1xuXG4gICAgICAgIC8vIGxpbmtzIGFyZSBzb21ldGltZXMgc3RvcmVkIGluIGFycmF5c1xuICAgICAgICAvLyB0aGlzIGZpbmRzIGlwZnMgbGlua3MgaW4gdGhlIGFycmF5XG4gICAgICAgIGlmKEFycmF5LmlzQXJyYXkoaXBmcykpe1xuICAgICAgICAgIGxldCBuZXdpcGZzID0gXCJcIjtcbiAgICAgICAgICBmb3IoY29uc3QgZWxlbWVudCBvZiBpcGZzKXtcbiAgICAgICAgICAgIG5ld2lwZnMgPSBuZXdpcGZzICsgZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYobmV3aXBmcy5zdGFydHNXaXRoKCdiYScpKXtcbiAgICAgICAgICAgIG5ld2lwZnMgPSBcImh0dHA6Ly9kd2ViLmxpbmsvaXBmcy9cIitpcGZzO1xuICAgICAgICAgICAgbmV3aXBmcyA9IG5ld2lwZnMucmVwbGFjZSgvLC9nLCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXdpcGZzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm9ybWFsIGlwZnMgaW4gaW1hZ2UgdGFnc1xuICAgICAgICBpZihpcGZzLnN0YXJ0c1dpdGgoJ2lwZnM6Ly8nKSl7XG4gICAgICAgICAgaXBmcyA9IGlwZnMuc2xpY2UoNyk7XG4gICAgICAgICAgaWYoaXBmcy5zdGFydHNXaXRoKCdpcGZzLycpKXtcbiAgICAgICAgICAgIGlwZnMgPSBpcGZzLnNsaWNlKDUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpcGZzID0gXCJodHRwOi8vZHdlYi5saW5rL2lwZnMvXCIraXBmcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGlwZnMuc3RhcnRzV2l0aCgnaXBmcy8nKSl7XG4gICAgICAgICAgaXBmcyA9IGlwZnMuc2xpY2UoNSk7XG4gICAgICAgICAgaXBmcyA9IFwiaHR0cDovL2R3ZWIubGluay9pcGZzL1wiK2lwZnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihpcGZzLnN0YXJ0c1dpdGgoJ1FtJykpe1xuICAgICAgICAgIGlwZnMgPSBcImh0dHA6Ly9kd2ViLmxpbmsvaXBmcy9cIitpcGZzO1xuICAgICAgICB9XG5cbiAgICAgIH1jYXRjaHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXBmcztcbiAgICBcbiAgICB9XG5cblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb2tlbiB7XG4gIGNvbnN0cnVjdG9yKGFzc2V0X25hbWUsIHBvbGljeV9pZCwgcXVhbnRpdHkpIHtcbiAgICB0aGlzLmFzc2V0X25hbWUgPSBhc3NldF9uYW1lO1xuICAgIHRoaXMucG9saWN5X2lkID0gcG9saWN5X2lkO1xuICAgIHRoaXMucXVhbnRpdHkgPSBxdWFudGl0eTtcbiAgICB0aGlzLm9uY2hhaW5fbWV0YWRhdGEgPSBudWxsO1xuICAgIHRoaXMubWV0YWRhdGEgPSBudWxsO1xuICAgIHRoaXMudHhzID0gbnVsbDtcbiAgICB0aGlzLmlwZnMgPSBudWxsO1xuICAgIHRoaXMucHJpY2VzID0gbnVsbDtcbiAgICB0aGlzLmltYWdlID0gbnVsbDtcbiAgfVxuXG4gIGFzeW5jIGZldGNoVG9rZW5EYXRhKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhc3NldElkID0gdGhpcy5wb2xpY3lfaWQgKyB0aGlzLmFzc2V0X25hbWU7XG4gICAgICBjb25zdCBbbWV0YWRhdGFSZXMsIHR4c1Jlc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGJsb2NrZnJvc3RGZXRjaChgYXNzZXRzLyR7YXNzZXRJZH1gKSxcbiAgICAgICAgYmxvY2tmcm9zdEZldGNoKGBhc3NldHMvJHthc3NldElkfS90cmFuc2FjdGlvbnNgKSxcbiAgICAgIF0pO1xuXG4gICAgICB0aGlzLm9uY2hhaW5fbWV0YWRhdGEgPSBtZXRhZGF0YVJlcy5vbmNoYWluX21ldGFkYXRhIHx8IG51bGw7XG4gICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGFSZXMubWV0YWRhdGEgfHwgbnVsbDtcbiAgICAgIHRoaXMudHhzID0gdHhzUmVzIHx8IG51bGw7XG5cbiAgICAgIHRoaXMuaXBmcyA9IGdldElwZnNGcm9tTWV0YWRhdGEodGhpcy5vbmNoYWluX21ldGFkYXRhIHx8IHt9KTtcbiAgICB9IGNhdGNoe1xuICAgIH1cbiAgfVxuICBcblxuICBhc3luYyBnZXRQcmljZSgpIHtcbiAgICBpZiAodGhpcy5xdWFudGl0eSA9PT0gMSkge1xuICAgICAgY29uc29sZS5sb2coJ05vdCBmdW5naWJsZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH10cnkge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IGF3YWl0IGZldGNoKCcvY29pbi1nZWNrby5qc29uJyk7XG4gICAgICBjb25zdCBnZWNrb0RhdGEgPSBhd2FpdCByZXF1ZXN0Lmpzb24oKTtcbiAgICAgIGNvbnN0IHRpY2tlciA9IHRoaXMubWV0YWRhdGE/LnRpY2tlcjtcbiAgICBcbiAgICAgIGlmICghdGlja2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBcbiAgICAgIGNvbnN0IGZvdW5kR2Vja29Db2luID0gZ2Vja29EYXRhLmZpbmQoaXRlbSA9PiBpdGVtLnN5bWJvbCA9PT0gdGlja2VyLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgaWYgKCFmb3VuZEdlY2tvQ29pbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgXG4gICAgICBjb25zdCByZXEgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9hcGkuY29pbmdlY2tvLmNvbS9hcGkvdjMvY29pbnMvJHtmb3VuZEdlY2tvQ29pbi5pZH1gKTtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJlcS5qc29uKCk7XG4gICAgXG4gICAgICBpZiAocmVzLmFzc2V0X3BsYXRmb3JtX2lkID09PSAnY2FyZGFubycpIHtcbiAgICAgICAgY29uc3QgcHJpY2VEYXRhID0gcmVzLm1hcmtldF9kYXRhO1xuICAgICAgICB0aGlzLnByaWNlcyA9IHtcbiAgICAgICAgICBjdXJyZW50OiBwcmljZURhdGEuY3VycmVudF9wcmljZS51c2QudG9GaXhlZCgyKSxcbiAgICAgICAgICBjaGFuZ2UyNGg6IHByaWNlRGF0YS5wcmljZV9jaGFuZ2VfcGVyY2VudGFnZV8yNGgudG9GaXhlZCgyKSxcbiAgICAgICAgICBjaGFuZ2U3ZDogcHJpY2VEYXRhLnByaWNlX2NoYW5nZV9wZXJjZW50YWdlXzdkLnRvRml4ZWQoMiksXG4gICAgICAgICAgY2hhbmdlMzBkOiBwcmljZURhdGEucHJpY2VfY2hhbmdlX3BlcmNlbnRhZ2VfMzBkLnRvRml4ZWQoMiksXG4gICAgICAgICAgY2hhbmdlMXk6IHByaWNlRGF0YS5wcmljZV9jaGFuZ2VfcGVyY2VudGFnZV8xeS50b0ZpeGVkKDIpLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwcmljZSBkYXRhOicsIGVycm9yKTtcbiAgICB9XG4gIH1cbn0gICAgXG4iXSwibmFtZXMiOlsiYmxvY2tmcm9zdEZldGNoIiwiZW5kcG9pbnQiLCJiYXNlVVJMIiwicHJvamVjdElkIiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJwcm9qZWN0X2lkIiwib2siLCJFcnJvciIsInN0YXR1c1RleHQiLCJqc29uIiwiZ2V0SXBmc0Zyb21NZXRhZGF0YSIsIm1ldGFkYXRhIiwia2V5cyIsIk9iamVjdCIsInZhbHVlcyIsImlwZnMiLCJpIiwibGVuZ3RoIiwiQXJyYXkiLCJpc0FycmF5IiwibmV3aXBmcyIsImVsZW1lbnQiLCJzdGFydHNXaXRoIiwicmVwbGFjZSIsInNsaWNlIiwiVG9rZW4iLCJmZXRjaFRva2VuRGF0YSIsImFzc2V0SWQiLCJwb2xpY3lfaWQiLCJhc3NldF9uYW1lIiwibWV0YWRhdGFSZXMiLCJ0eHNSZXMiLCJQcm9taXNlIiwiYWxsIiwib25jaGFpbl9tZXRhZGF0YSIsInR4cyIsImdldFByaWNlIiwicXVhbnRpdHkiLCJjb25zb2xlIiwibG9nIiwicmVxdWVzdCIsImdlY2tvRGF0YSIsInRpY2tlciIsImZvdW5kR2Vja29Db2luIiwiZmluZCIsIml0ZW0iLCJzeW1ib2wiLCJ0b0xvd2VyQ2FzZSIsInJlcSIsImlkIiwicmVzIiwiYXNzZXRfcGxhdGZvcm1faWQiLCJwcmljZURhdGEiLCJtYXJrZXRfZGF0YSIsInByaWNlcyIsImN1cnJlbnQiLCJjdXJyZW50X3ByaWNlIiwidXNkIiwidG9GaXhlZCIsImNoYW5nZTI0aCIsInByaWNlX2NoYW5nZV9wZXJjZW50YWdlXzI0aCIsImNoYW5nZTdkIiwicHJpY2VfY2hhbmdlX3BlcmNlbnRhZ2VfN2QiLCJjaGFuZ2UzMGQiLCJwcmljZV9jaGFuZ2VfcGVyY2VudGFnZV8zMGQiLCJjaGFuZ2UxeSIsInByaWNlX2NoYW5nZV9wZXJjZW50YWdlXzF5IiwiZXJyb3IiLCJjb25zdHJ1Y3RvciIsImltYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/token.js\n"));

/***/ })

});